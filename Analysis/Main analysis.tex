\documentclass[a4paper,12pt]{article}

\usepackage[latin1]{inputenc}
\usepackage[spanish,es-tabla]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage{units}
\usepackage{color}
\usepackage{float}
\usepackage{longtable}
\usepackage{mathrsfs}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{relsize}
%\usepackage{mathabx}
\usepackage{ulem}

\bibliographystyle{alpha}

%\doublespacing
\clubpenalty=10000
\widowpenalty=10000

\DeclareMathOperator{\arccot}{arc\ cot}
\DeclareMathOperator{\arcsec}{arc\ sec}
\DeclareMathOperator{\arccsc}{arc\ csc}
\DeclareMathOperator{\sech}{sech}
\DeclareMathOperator{\csch}{csch}
\DeclareMathOperator{\argsenh}{arg\ senh}
\DeclareMathOperator{\argcosh}{arg\ cosh}
\DeclareMathOperator{\argtgh}{arg\ tgh}
\DeclareMathOperator{\argcoth}{arg\ coth}
\DeclareMathOperator{\argsech}{arg\ sech}
\DeclareMathOperator{\argcsch}{arg\ csch}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\mcd}{mcd}
\DeclareMathOperator{\modX}{m\acute od}
\DeclareMathOperator{\Cov}{Cov}

\pgfplotsset{compat=1.12}

\begin{document}

\newlength{\origpar}
\setlength{\origpar}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\parindent}{\origpar}

\renewcommand {\baselinestretch} {1.0}
\renewcommand*{\arraystretch}{1.5}

\newcommand{\paren}[1]{\ensuremath{\left(#1\right)}}
\newcommand{\corch}[1]{\ensuremath{\left[#1\right]}}
\newcommand{\llave}[1]{\ensuremath{\left\{#1\right\}}}
\newcommand{\angparen}[1]{\ensuremath{\left<#1\right>}}
\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\vecnorm}[1]{\ensuremath{\left|\left|#1\right|\right|}}
\newcommand{\pdiff}[2]{\ensuremath{\dfrac{\partial#1}{\partial#2}}}
\newcommand{\tlap}[1]{\ensuremath{\mathscr L\llave{#1}}}
\newcommand{\itlap}[1]{\ensuremath{\mathscr L^{-1}\llave{#1}}}
\newcommand{\Section}[1]{\renewcommand{\thesection}{#1}\section}
\newcommand{\floor}[1]{\ensuremath{\left\lfloor#1\right\rfloor}}
\newcommand{\ceil}[1]{\ensuremath{\left\lceil#1\right\rceil}}

\newcommand{\zm}[1]{\ensuremath{\mathbb Z/#1\mathbb Z}}

\definecolor{grey}{rgb}{0.50,0.50,0.50}
\definecolor{moradoesfruta}{rgb}{1,0,1}
\definecolor{orangeisthenewmorado}{rgb}{1,0.5,0}

\newcommand{\inRed}[1]{\textcolor{red}{#1}}
\newcommand{\inBlue}[1]{\textcolor{blue}{#1}}
\newcommand{\inGreen}[1]{\textcolor{green}{#1}}
\newcommand{\inPurple}[1]{\textcolor{moradoesfruta}{#1}}
\newcommand{\inOrange}[1]{\textcolor{orangeisthenewmorado}{#1}}

\newcommand{\SectionR}[1]{\renewcommand{\thesection}{\inRed{#1}}\section}
\newcommand{\SectionG}[1]{\renewcommand{\thesection}{\inGreen{#1}}\section}
\newcommand{\SectionO}[1]{\renewcommand{\thesection}{\inOrange{#1}}\section}

\newcommand{\matlab}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{black}{#1}}}\end{singlespace}}
\newcommand{\maxima}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{blue}{#1}}}\end{singlespace}}
\newcommand{\maximaoutput}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{grey}{#1}}}\end{singlespace}}
\newcommand{\scilab}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{black}{#1}}}\end{singlespace}}

% Magia negra de Latex a continuación (copiada de http://tex.stackexchange.com/questions/44235/is-there-a-way-to-do-an-upside-down-widehat).
\makeatletter
\DeclareRobustCommand\widecheck[1]{{\mathpalette\@widecheck{#1}}}
\def\@widecheck#1#2{%
    \setbox\z@\hbox{\m@th$#1#2$}%
    \setbox\tw@\hbox{\m@th$#1%
       \widehat{%
          \vrule\@width\z@\@height\ht\z@
          \vrule\@height\z@\@width\wd\z@}$}%
    \dp\tw@-\ht\z@
    \@tempdima\ht\z@ \advance\@tempdima2\ht\tw@ \divide\@tempdima\thr@@
    \setbox\tw@\hbox{%
       \raise\@tempdima\hbox{\scalebox{1}[-1]{\lower\@tempdima\box
\tw@}}}%
    {\ooalign{\box\tw@ \cr \box\z@}}}
\makeatother
% Fin de la magia negra.

\setcounter{secnumdepth}{3}
\section{Multiples of 3 and 5}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 233168. \textit{Solved: Sat, 8 Aug 2015, 08:09}.

\textbf{Math knowledge used}: triangular numbers.

\textbf{Programming techniques used}: none.

It's very simple using inclusion-exclusion. We count how many multiples of $3$, $5$ and $15$ are there, then we use triangular numbers to determine each sum, then we return $\mathrm{sum}\paren3+\mathrm{sum}\paren5-\mathrm{sum}\paren{15}$.

\section{Even Fibonacci numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4613732. \textit{Solved: Sat, 8 Aug 2015, 08:23}.

\textbf{Math knowledge used}: recurrence equation theory.

\textbf{Programming techniques used}: none.

You can bruteforce this very easily. Or you can use recurrence equations! Which is of course my preferred method since it's more mathematical and, much more importantly, more scalable.

So, fibonacci numbers follow this formula:
\begin{equation*}
f\paren n=\dfrac{\varphi^n-\paren{1-\varphi}^n}{\sqrt5}.
\end{equation*}

And even fibonacci numbers are precisely those for which $n=\dot3$. That is, the numbers we are looking for follow this other formula:
\begin{equation*}
f_{\mathrm even}\paren n=\dfrac{\varphi^{3n}-\paren{1-\varphi}^{3n}}{\sqrt5}.
\end{equation*}

From this, considering that $\paren{1-\varphi}^{3n}$ tends to $0$ very rapidly, and calling $L=4e6$ the imposed limit, we can get a suitable formula for the largest $n$ we need:
\begin{equation*}
N=\floor{\dfrac{\log L}{3\log\varphi}}.
\end{equation*}

Finally, since we need the sum, we use a basic summation formula (again, considering that the $\paren{1-\varphi}^{3n}$ terms tend quickly to zero):
\begin{equation*}
\sum_{i=0}^n\dfrac{\varphi^{3n}-\paren{1-\varphi}^{3n}}{\sqrt5}\approx\sum_{i=0}^n\dfrac{\varphi^{3n}}{\sqrt5}=\dfrac{\varphi^{3n+3}-\varphi^3}{\paren{\varphi^3-1}\sqrt5}.
\end{equation*}
Rounding this value into the nearest integer we get the solution.

\section{Largest prime factor}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 6857. \textit{Solved: Sat, 8 Aug 2015, 08:33}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

Very simple, just enumerate all the primes up to $\sqrt L$ (with $L$ being the limit) and then divide until either we hit $1$ (meaning that the last prime we divided by is the result) or we run out of primes (meaning that the remaining number is the last prime we're looking for).

There are many methods that can be used to iterate over the primes, but the Erathostenes sieve is good enough. Saying that it will be used profusely is a big, big understatement.

\section{Largest palindrome product}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 906609. \textit{Solved: Sat, 8 Aug 2015, 08:39}.

\textbf{Math knowledge used}: modular arithmetic.

\textbf{Programming techniques used}: none.

The ``modular arithmetic'' I'm referring to is just the fact that I know that all palindrome numbers with an even amount of digits are multiples of $11$. So, the method to found this answer is as simple as iterating downwards over a pair of factors, but this bit of knowledge allows me to reduce the search space by 11, because one of the factors iterates over just multiples of $11$.

\section{Smallest multiple}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 232792560. \textit{Solved: Sat, 8 Aug 2015, 08:49}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve (for divisor generation).

\textbf{Programming techniques used}: none.

I'm not sure if ``none'' qualifies as the list of special knowledge used. I just factored all the numbers and then calculated the least common multiple in a more or less intelligent way (i.e. I have the factors, so no need to use Euclid's algorithm). This is the first time I used my DivisorHolder class, which is used for a fuckton of problems all over the list.

\section{Sum square difference}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 25164150. \textit{Solved: Sat, 8 Aug 2015, 08:54}.

\textbf{Math knowledge used}: basic Faulhaber formulas.

\textbf{Programming techniques used}: none.

The sum of all natural numbers up to $n$ is $\dfrac{n\paren{n+1}}2$, and if we square this we get:
\begin{equation*}
f\paren n=\dfrac{n^4+2n^3+n^2}4.
\end{equation*}

On the other hand, the sum of the squares of all the natural numbers up to $n$ is
\begin{equation*}
g\paren n=\dfrac{2n^3+3n^2+n}6.
\end{equation*}

Subtracting both numbers we get the formula we need:
\begin{equation*}
f\paren n-g\paren n=\dfrac{3n^4+2n^3-3n^2-2n}{12}.
\end{equation*}

Plugging in $n=100$ we get the result. By the way, it can be easily proven that despite the denominator this number is always an integer.

\section{10001st prime}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 104743. \textit{Solved: Sat, 8 Aug 2015, 09:02}.

\textbf{Math knowledge used}: Erathostenes sieve, $\pi\paren n$ counting function.

\textbf{Programming techniques used}: none.

Just use an Erathostenes sieve. As for the limit, we know that $\pi\paren x\approx\dfrac x{\log x}$, so if the limit is $L=10001$, then we can use $N=2L\log L$ (multiplying times $2$ is a safe addition. The formula I gave means that $x\approx\log x\cdot\pi\paren x$, but we have $\pi x$, and this formula doesn't say anything about $\log\pi\paren x\cdot\pi\paren x$). Then just move over the sieve until we have passed over $L$ primes.

\section{Largest product in a series}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 23514624000. \textit{Solved: Sat, 8 Aug 2015, 09:11}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

This is more algorithmic than mathematic, but still, it's not like it has much algoritmic depth. You can either iterate over the list, taking care about how the zeros break the chains, or just split the string into smaller strings of digits using the $0$ as separator, so that the remaining strings are safer to iterate. In any case the search algorithm is basically obvious (take the first $N$ digits as product, then at each step divide by the $\paren{i-N}$-th and multiply by the $i$-th. Take the maximum you found).

\section{Special Pythagorean triplet}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 31875000. \textit{Solved: Sat, 8 Aug 2015, 09:20}.

\textbf{Math knowledge used}: Pythagorean triples generation.

\textbf{Programming techniques used}: none.

So, this is the first problem that uses Pythagorean triple generation, another staple of Project Euler (not nearly as ubiquitous as prime generation, but still). This problem is very simple: if we can reliably generate all the primitives, then we will find some primitive so that $a+b+c=k$ and $N=1000$ is a multiple of $k$, $N/k=q\in\mathbb N$. In that case, we scale the triple to get $\paren{qa,qb,qc}$ so that $qa+qb+qc=1000$, and so the answer is $\paren{qa}\paren{qb}\paren{qc}=q^3abc$. By the way, the solution is the triple $\paren{15,8,17}$, which gets scaled into $\paren{375,200,425}$.

\section{Summation of primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 142913828922. \textit{Solved: Sat, 8 Aug 2015, 09:42}.

\textbf{Math knowledge used}: Prime summation function.

\textbf{Programming techniques used}: none.

This is an \textit{absolutely awesome} problem, disguised as a boring tutorial. Now, in certain way I could say the same about problem 2, right? But in that case, the interesting technique is very widely known and available to every first year maths student. In this case the magic is a little more obscure, although it's still very useful all over Project Euler.

So, the magic is that there is a recursive function that calculates the sum of primes in something like $O\paren{n^{2/3}}$ time, meaning that the result of this problem takes about $30$ milliseconds to get, AND that if I want to calculate the sum of all primes up to, say, $10^{12}$, it's perfectly doable. No need to generate all the primes explicitly. Yes, this \textit{will} be used (sparingly, but decisively) all over Project Euler.

Credits for this awesome function go to user \textbf{Lucy\_Hedgehog} of Project Euler. The algorithm itself is described in the comments of the problem, in what could very well be the highest rated comment of all the site.

\section{Largest product in a grid}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 70600674. \textit{Solved: Sat, 8 Aug 2015, 10:23}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Just a rehash of problem 8, more complicated because there are a lot more lines to take into account. This is purely algorithmic but it's more grit than anything. What I did was:
\begin{enumerate}[1.]
\item Parse the input into a 2D int array.
\item Generate all the horizontal, vertical and diagonal (in both directions) lines.
\item For each one of the generated lines, separate them into zero-less chunks, discarding the ones that are too short.
\item Get the maximum product of each of these chunks, using the very same function as in problem 8.
\item The maximum of all chunks' maxima is the result.
\end{enumerate}

\section{Highly divisible triangular number}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 76576500. \textit{Solved: Sat, 8 Aug 2015, 11:00}.

\textbf{Math knowledge used}: triangular numbers, ``first prime'' Erathostenes sieve (for divisor generation).

\textbf{Programming techniques used}: none.

Very easy. For each $N\geq2$, get the prime factorisation of both $N-1$ and $N$, combine them, then remove a $2$. Count the amount of divisors of the resulting number, and if it's greater than the limit, return the number $\dfrac{N\paren{N-1}}2$. All of this can be reliably done with my DivisorHolder class that keeps the factorisation using an IntIntMap.

By the way, the answer comes from $N=12376$, i.e. from $T\paren{12375}$. $12375=3^2\cdot5^3\cdot11$ and $12376=2^3\cdot7\cdot13\cdot17$, so the resulting triangular number is $2^2\cdot3^2\cdot5^3\cdot7\cdot11\cdot13\cdot17$, which has $3\cdot3\cdot4\cdot2\cdot2\cdot2\cdot2=576$ divisors.

\section{Large sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 5537376230. \textit{Solved: Sat, 8 Aug 2015, 11:30}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I wouldn't call the usage of BigInteger a ``programming technique''. In the end this problem isn't even algorithmic. On the good side, this is a good example of the advantage of Java Streams, since I can do all the additions without resorting to an explicit list of BigInteger; the original stream of lines returned by Files.lines can be used directly. Yay, I guess.

In most Project Euler problems, and that includes this one, the usage of BigInteger (or integers larger than 64 bits, for that matter) is not strictly unneeded. Still, there are many problems where they come in very handy.

\section{Longest Collatz sequence}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 837799. \textit{Solved: Sat, 8 Aug 2015, 11:54}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: memoisation.

This can be done without memoisation, but it's super slow. With memoisation, it takes less than half a second, which is much more than anything before this problem but it's still short and sweet.

\section{Lattice paths}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 137846528820. \textit{Solved: Sat, 8 Aug 2015, 11:59}.

\textbf{Math knowledge used}: combinatorial numbers.

\textbf{Programming techniques used}: none.

Very simple. The amount of routes is just the amount of permutations between $20$ displacements to the right and $20$ displacements to the bottom. Therefore the result is $\displaystyle\binom{20+20}{20}$.

Of course, you can also try to manually enumerate all the possible paths. Good luck. This might be the first problem where, if you are \textit{completely} clueless, there's no way you are going to get the result.

\section{Power digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1366. \textit{Solved: Sat, 8 Aug 2015, 12:18}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: binary exponentiation.

This is one of the very few cases where I don't think you can solve this problem without resorting to a BigInteger or to a similar trick like a string of digits. It's not like it's much of a problem, though.

I'm counting binary exponentiation as a programming technique, although it's a very simple one (and arguably you could put into the ``mathematical knowledge'' bin). This will also be used very often all over Project Euler.

\section{Number letter counts}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 21124. \textit{Solved: Sat, 8 Aug 2015, 12:37}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I'm a bit torn about this problem. On one hand, the concept is kind of beautiful. I'm almost tempted to solve it in different languages like German or Finnish. On the other hand, coding it was repetitive and tedious.

The obvious way to solve this problem is generating all the strings and counting all the letters. Super-tedious. What I did was different: I enumerated all the words and then counted, for each one, in how many words appeared (all the cases are reasonably simple). Multiplying by the word's length, and adding the results, yields the solution.

\section{Number letter counts}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1074. \textit{Solved: Sat, 8 Aug 2015, 13:03}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: greedy algorithm.

Finally some actual algorithmics, even if very simple. A greedy algorithm that gets the best sum from both ``parents'' from above is good enough.

\section{Counting Sundays}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 171. \textit{Solved: Sat, 8 Aug 2015, 13:14}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

This is stupidly simple but I kept getting the wrong result because I used a monday as a starting point, but this is not what I need to use since I must count from 1901 onwards and the date I'm given is from 1900, not 1901.

The method itself: well, there are only 14 types of years. So I count how many of each type are there in the period from 1901 to 2000, then for each year type I count how many months start on a Sunday. Multiply and accumulate the sum. End.

\section{Factorial digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 648. \textit{Solved: Sat, 8 Aug 2015, 13:16}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Similar to problem 16, but even more simple because there is no binary exponentiation, just creating the factorial and adding the digits. Not much more to add, except that this is one of the cases where BigInteger or equivalent is really, actually needed.

\section{Amicable numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 31626. \textit{Solved: Sat, 8 Aug 2015, 13:40}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve (for divisor generation), divisor sum properties.

\textbf{Programming techniques used}: memoisation.

The formula I've listed under ``divisor sum properties'' is the following: if a number's prime decomposition is
\begin{equation*}
N=\prod_{i=1}^mp_i^{e^i},
\end{equation*}
then the sum of its divisors is
\begin{equation*}
S\paren N=\prod_{i=1}^m\dfrac{p_i^{e^i+1}-1}{p_i-1}.
\end{equation*}
So the proper sum of divisors is $S\paren N-N$, and that's all the maths needed for this problem. So we keep two maps of $N\rightarrow S\paren N-N$, one with the abundant numbers ($S\paren N>2N$) and another one with the defective numbers ($S\paren N<2N$). No need to store perfect numbers. Then we iterate over the abundant numbers map (which is the smaller of the two), looking for entries where the key-value pair appears as value-key in the defective map. Of course, a single map can be used with all the numbers, but it will be slightly slower.

\section{Names scores}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 871198282. \textit{Solved: Sat, 8 Aug 2015, 14:05}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Yeah, I refuse to call a sort function a ``programming technique''. I don't like this problem, mostly because it's too streamlined and basically the description tells you exactly what to do. No room for finesse or for improvements. Just read the (single line) file, parse it into a list of names, sort it, then use the given algorithm to calculate the result.

\section{Non-abundant sums}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4179871. \textit{Solved: Sat, 8 Aug 2015, 14:20}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve (for divisor generation), divisor sum properties.

\textbf{Programming techniques used}: none.

Using the same divisor function as in problem 21, the algorithm is simple: generate the set all the abundant numbers up to the given limit using said numbers, then generate all the possible sums of two values of the set below the limit. Then iterate over all the numbers up to the limit and add them to a tally if they are not in the set of sums. There is a modicum of brute force in the sum generation process so this takes nearly half a second.

\section{Lexicographic permutations}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 2783915460. \textit{Solved: Sat, 8 Aug 2015, 14:36}.

\textbf{Math knowledge used}: factorial number system.

\textbf{Programming techniques used}: none.

I said that I didn't like 22, right? 24 is the opposite. It's very nice, and for such an early problem, it has room for a clever usage of maths that eschews brute force. I could have replaced the math knowledge about the factoradic system with programming technique about permutation enumeration, but that would require a million operations, while using factoradic requires ten, and probably faster ones.

In a nutshell: you can either enumerate a million partitions (slow) or just represent $10^6-1$ in factoradic (fast!). I obviously opted for the second way.

\section{1000-digit Fibonacci number}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4782. \textit{Solved: Sat, 8 Aug 2015, 14:41}.

\textbf{Math knowledge used}: recurrence equation theory.

\textbf{Programming techniques used}: none.

Just like in problem 2, we can use the formula
\begin{equation*}
F_n=\dfrac{\varphi^n-\paren{1-\varphi}^n}{\sqrt5}\approx\dfrac{\varphi^n}{\sqrt5}.
\end{equation*}
We need to calculate the first $n$ so that $F_n\geq10^{1000-1}$ (note that $10^{1000}$ has \textit{1001} digits, not 1000). Solving for $n$ we get:
\begin{equation*}
\dfrac{\varphi^n}{\sqrt5}\geq10^{999}\Rightarrow n\geq\dfrac{999\log10+\log\sqrt5}{\log\varphi}\Rightarrow n=\ceil{\dfrac{999\log10+\log\sqrt5}{\log\varphi}}.
\end{equation*}
Of course this calculation is super fast, on par with the first two problems in speed.

\section{Reciprocal cycles}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 983. \textit{Solved: Sat, 8 Aug 2015, 15:03}.

\textbf{Math knowledge used}: infinite decimal period distributions.

\textbf{Programming techniques used}: none.

The keys to this algorithm are two: the first one is that the period length of $1/n$ can only have as much as $n-1$ digits; the second one is that $n-1$ is only reached, in fact, if $n$ is prime. While it's not strictly true that the result \textit{needs} to be a prime, it's very likely, so I just iterated downwards over the primes, calculating the cycle length and stopping whenever the current value was smaller than the greatest length found. The result is found almost instantly (less than 1ms) because the result is close to the limit.

\section{Quadratic primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: -59231. \textit{Solved: Sat, 8 Aug 2015, 15:20}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

The only useful insight for this problem is that $b$ has to be a prime, otherwise of course we don't get any prime because for $n=0$ the polynomial doesn't yield a prime and we stop immediately. Also, once this is taken care of, we can start the iterations from $n=1$ instead of $n=0$ since of course we got a prime for $n=0$. This shaves some... nanoseconds? from the run time. Another nano-optimisation is calculating the polynomial value by incrementing the previous value in $2n+a-1$, instead of calculating the complete value each time. Aside from all that swill, this is just iterating over $\corch{-L\ldots L}$ for $a$, and over the primes smaller than $L$ for $b$, and then calculating the polynomial values. By the way, the solution is reached for $a=-61$, $b=971$, for a total of $71$ primes.

\section{Number spiral diagonals}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 669171001. \textit{Solved: Sat, 8 Aug 2015, 15:34}.

\textbf{Math knowledge used}: basic Faulhaber formulas.

\textbf{Programming techniques used}: none.

Another hyper-fast one. Sure, you can iterate over the numbers and build the spiral manually or whatever, but why do that when each half diagonal follows a very clear formula? So, if the length we are looking for is $L=1001$, the half diagonals have a size of $N=\dfrac{L-1}2=500$. The formulas for the half diagonal numbers are very simple:
\begin{eqnarray*}
F_1\paren n&=&4n^2-2n+1;\\
F_2\paren n&=&4n^2+1;\\
F_3\paren n&=&4n^2+2n+1;\\
F_4\paren n&=&4n^2+4n+1.
\end{eqnarray*}
The sum of all these values is $S\paren n=16n^2+4n+4$, so the result of the problem is
\begin{equation*}
1+\sum_{n=1}^N\paren{16n^2+4n+4}=1+4N+4\sum_{n=1}^Nn+16\sum_{n=1}^Nn^2.
\end{equation*}
With the Faulhaber formulas for $k=1$ and $2$ we can summarise this result as
\begin{equation*}
1+\dfrac{32N^3+60N^2+52N}6.
\end{equation*}
Plugging $N=500$ yields the result.

Side note: I'm slightly triggered by the fact that the spiral moves in \sout{clockwise}negative direction.

\section{Distinct powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 9183. \textit{Solved: Sat, 8 Aug 2015, 15:46}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I overengineered this problem in order to make a generic algorithm that would work for bigger values. It was \textit{delightful}.

The obvious algorithm generates all the algorithm (using BigInteger, or logarithms, or whatever). Instead, what I did was counting the amount of powers of each type present in the algorithm, and for each of them, I counted the new exponents that each type could generate. In the given range there are $87$ normal numbers ($99$ new values each), $6$ square numbers ($50$ new values each), $2$ cubes ($50$ new values each), $2$ fourth powers ($41$ new values each), and a fifth and a sixth power ($51$ and $37$ new values respectively). So: $87\cdot99+6\cdot50+2\cdot50+2\cdot41+51+37=9183$.

\section{Digit fifth powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 443839. \textit{Solved: Sat, 8 Aug 2015, 16:13}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: combination generation (with repetition).

Ah, yes. Reusing pays. I have a generic combination generator which is \textit{very useful} since there are a lot of problems that require generating all the \textit{unordered} combinations of certain set of values. I started it long ago and it's currently refined into a very reasonable, fast and usable class. So, with that generator in my hands, I just need to generate all \textit{six} or less combinations of numbers between $0$ and $9$, and for each of them, verify whether the sum of fifth of powers matches the combination. Why six digits, precisely? Because for seven digits we can't get numbers, because the maximum valus is below the minimum: $7\cdot9^5<10^{7-1}$. For six digits it happens that $6\cdot9^5\geq10^{6-1}$, so they must be taken into account.

There are six such numbers: $4150$, $4151$, $93084$, $92727$, $54748$ and $194979$. See, I told you, six digits are needed.

\section{Coin sums}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 73682. \textit{Solved: Sat, 8 Aug 2015, 16:29}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Classic dynamic programming problem. Only two arrays need to be kept at each time: the previous one, $P$, which for each index $i$ contains the amount of ways to sum up to $i$ using all the previously visited coins, and the new one, $N$, associated to the new coin with value $c$, which we generate like this:
\begin{equation*}
N\corch i=\sum_{k=0}^{\floor{\frac ic}}P\corch{i-kc}.
\end{equation*}
The first array for $c=1$ is all ones, and then we iterate for each one of the remaining coins, $c\in\llave{2,5,10,20,50,100,200}$. The problem solution is the value for index $200$ in the last array.

\section{Pandigital products}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 45228. \textit{Solved: Sat, 8 Aug 2015, 17:14}.

\textbf{Math knowledge used}: basic modular arithmetic.

\textbf{Programming techniques used}: none.

This is a bit tedious, but the culling process is interesting. First, about the sizes of the numbers: the only valid sizes are $\paren2\times\paren3=\paren4$ and $\paren1\times\paren4=\paren4$. Just iterating over these sizes is enough (less than $20000$ products, not bad), but we can cull even more if we take into account that the moduli of the products have to verify $n1+n2+(n1\cdot n2)\equiv0$ (mod $9$). This leaves jsut a few cases: $\paren{1,4}$, $\paren{3,6}$, $\paren{7,7}$ and $\paren{0,0}$. In the first two cases we also need to consider the reverse pairs, $\paren{4,1}$ and $\paren{6,3}$. So, for each combination of (pair of sizes) and (pair of moduli) we generate the possible pairs using a mere arithmetic progression, and we verify the products. So for each pair or arithmetic progression we have a nested loop, and we can cull a bit further by breaking the inner loop when we hit a product with more than $4$ digits.

The program takes a bit to write but it's very fast. There aren't too many solutions:
\begin{itemize}
\item $4\cdot 1738=6952$.
\item $4\cdot 1963=7852$.
\item $28\cdot 157=4396$.
\item $12\cdot 483=5796$.
\item $39\cdot 186=7254$.
\item $48\cdot 159=7632$.
\item $42\cdot 138=5796$ (already found).
\item $18\cdot 297=5346$.
\item $27\cdot 198=5346$ (already found).
\end{itemize}

\section{Digit cancelling fractions}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 100. \textit{Solved: Sat, 8 Aug 2015, 17:25}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Obviously all the fractions have to be of the form $\frac{ab}{bc}$. So we just iterate over triples $\paren{a,b,c}$ (we can also assume $b>a$ and $b>c$), and we get the four results very quickly: $\frac{16}{64}=\frac14$, $\frac{19}{95}=\frac15$, $\frac{26}{65}=\frac25$ and $\frac{49}{98}=\frac48$. Then we accumulate the product of all the $\frac ac$ cases, getting $\frac8{800}=\frac1{100}$.

\section{Digit factorials}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 40730. \textit{Solved: Sat, 8 Aug 2015, 17:30}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: combination generation (with repetition).

This is a lot like problem 30, but here I needed to take care about leading zeros. This wasn't a problem in 30 because $0^5=0$, but here we have $0!=1$ so I need to subtract excess leading zeros. Aside from that, the code is almost identical (I need to use up to 7 digits since $9!\cdot7\geq10^{7-1}$, but $9!\cdot8<10^{8-1}$).

There are only two solutions: $145=1+24+120$ and $40585=24+1+120+40320+120$.

\section{Circular primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 55. \textit{Solved: Sat, 8 Aug 2015, 18:05}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: custom combination generation.

They are starting to get tricky. It's not that this is impossible or something, but we need to start taking care about things like generating numbers efficiently (well, not really. This is still bruteforceable), avoiding repetition and so on. I created a custom combination class that I expect to use often.

Anyway: the cases for 1 digit are handled separately (i.e. just add 4 to the final result). As for the rest, I generate all the combinations of odd numbers with $N$ digits, for $N\in\corch{2,6}$, and for each combination, I search for primality in all the generated circular numbers. Not that difficult, but laborious.

\section{Double-base palindromes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 872187. \textit{Solved: Sat, 8 Aug 2015, 18:40}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

The easiest way to do this, by far, is to generate all the palindromes in base $10$ and then check whether they are palindromes in base $2$. And in order to generate palindromes in base $10$, we just generate ``half'' of the palindrome (the bottom numbers) and mirror the rest. A bit of cleverness is needed about the leading zeroes, but nothing tough.

\section{Truncatable primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 748317. \textit{Solved: Sat, 8 Aug 2015, 19:01}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: custom combination generator.

I don't think that providing an explicit limit for the Eraatahostenes sieve is cheating or anything like that. If I had found fewer than $11$ primes, I would have increased the amount of digits.

Anyway: I generate all the candidates (numbers that can start with any odd number or 2, and where the rest of the digits are odd and not $5$), and for each of them, I check whether they are truncatable with the help of a premade Erathostenes sieve. Not much more complicated than that.

The truncatable primes are: $23$, $37$ (of course!), $53$, $73$, $313$, $317$, $373$, $797$, $3137$, $3797$ and $739397$.

\section{Pandigital multiples}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 932718654. \textit{Solved: Sat, 8 Aug 2015, 19:09}.

\textbf{Math knowledge used}: modular arithmetic.

\textbf{Programming techniques used}: none.

This can be solved incredibly fast with the help of some previous analysis.
\begin{itemize}
\item We already know a number: $918273645$, which conveniently starts with a $9$, reducing the search space by a lot. Also no other $1$ digit starting number can be greater than this since obviously it would be smaller than $9$.
\item For two digit numbers, they must verify that $3x<100$ and $4x\geq100$ so that the concatenation has $9$ digits. This means that $25\leq x<34$ and therefore the resulting number will never be greater than the known case.
\item For three digit numbers, they have to verify $3x<1000$, so $x<334$ and there's no way they can be greater than the known case.
\item For four digit numbers we need to verify some cases. The only restriction is $2x\geq10000$. Also we don't need to look further than $9182$. Finally, the number must be a multiple of $3$ so that the concatenation of $x$ and $2x$ is a multiple of 9 (this bit is the ``modular arithmetic'' knowledge mentioned above).
\end{itemize}
So we can just iterate from $9999$ to $9183$ in intervals of $-3$, return immediately if $\paren{10^5+2}x$ is pandigital, and return $918273645$ if we don't find any.

\section{Integer right triangles}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 840. \textit{Solved: Sat, 8 Aug 2015, 19:21}.

\textbf{Math knowledge used}: Pythagorean triples generation.

\textbf{Programming techniques used}: none.

We need to generate all the primitive Pythagorean triples with perimeter smaller or equal than the given amount, and then for each perimeter $p$ we increase counters for all the multiples of $p$ below the limit (since the triangle can be scaled). Then we iterate over the counters and return the one where the index is the highest, which is $840$ with a measly $8$ solutions.

\section{Champernowne's constant}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 210. \textit{Solved: Sat, 8 Aug 2015, 19:30}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

It's all about being careful about how numbers are being generated. I divided the decimals in ``chunks'' of numbers with fixed amounts of digits: $9$ with $1$ digit, $90$ with $2$, and so on. In the end:
\begin{itemize}
\item The $1$st digit is $1$, of course.
\item The $10$th digit is the $1$ in $10$.
\item The $100$th digit is the first $5$ (tens) in $55$.
\item The $1000$th digit is the $3$ in $370$.
\item The $10000$th digit is the unit $7$ in $2777$.
\item The $100000$th digit is the $2$ in the thousands from $22222$.
\item Finally, the millionth digit is the first one (hundreds of thousands) from $185185$.
\end{itemize}
It takes a bit too long ($25$ milliseconds), for something that can be reasonably done by hand in a couple minutes top.

\section{Pandigital prime}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 7652413. \textit{Solved: Sat, 8 Aug 2015, 20:17}.

\textbf{Math knowledge used}: Miller-Rabin primality test.

\textbf{Programming techniques used}: permutation iterator.

This is the first usage of the robust permutation iterator based on C++'s next\_permutation. The algorithm is quite simple: for each amount of digits, iterate downwards over all the possible digit permutations, and then return the first prime found. Using Miller-Rabin for the primality test, just like I could have used a (kind of big) Erathostenes sieve.

The only sizes we need to iterate over are $1$, $4$ and $7$, since otherwise the sum of the first $N$ digits is a multiple of $3$, so the resulting number is never a prime. Obviously the result has $7$ digits.

\section{Coded triangle numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 162. \textit{Solved: Sat, 8 Aug 2015, 20:23}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Very boring, not much substance. Let's see: suppose that $K$ is a hypothetical triangular number. In that case, some integer $n$ verifies:
\begin{equation*}
\dfrac{n^2+n}2=K\Rightarrow n^2+n-2K=0\Rightarrow n=\dfrac{-1\pm\sqrt{1+8K}}2.
\end{equation*}
Now, if the square root is exact, it must be an odd number, so after subtracting 1 we get an even one so we can divide by two. In other words, if the square root is exact, then $n$ is an integer, which means that $K$ is a triangular number if an only if $1+8K$ is a perfect square.

The algorithm is clear and it doesn't offer much room for improvement: read all the words, calculate their ``value'' shamelessly reusing code from problem 22, and verify whether their value verifies the condition above.

\section{Sub-string divisibility}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 16695334890. \textit{Solved: Sat, 8 Aug 2015, 21:09}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

After the previous boring problem, this one is much more fun. The analysis can be done by hand:
\begin{itemize}
\item $d_4d_5d_6$ is a multiple of $5$, therefore $d_6$ is either $0$ or $5$.
\item However, if $d_6=0$, then $d_6d_7d_8=0d_7d_8$, which is only a multiple of $11$ if $d_7=d_8$, which can not happen. So $d_6=5$.
\item Now we have several possible cases for $d_7d_8$, considering that $5d_7d_8$ must be a multiple of $11$:
\begin{itemize}
\item $d_7d_8=06$. In this case, $d_9=5$ so that $065$ is a multiple of $13$, but we have already used the $5$, so this is not valid.
\item $d_7d_8=17$. There is no three digit multiple of $13$ starting with $17$, so es geht nicht.
\item $d_7d_8=28$. This forces $d_9=6$ and $d_{10}=7$. Nice so far. Also $d_5$ has to be $9$ (it could be $2$, but we already used it). And looking at $d_3d_4d_5$, we know that $\llave{d_3,d_4}=\llave{0,3}$ so that we get a multiple of $3$. Since $d_4$ must be even, necessarily we get $d_4=0$, $d_3=3$. So we get $d_1d_230952867$ where $\llave{d_1,d_2}=\llave{1,4}$. Great!
\item $d_7d_8=39$. Then $d_9=0$ and there is no suitable value for $d_{10}$.
\item $d_7d_8=50$ is not valid because we already are using $5$.
\item $d_7d_8=61$. The only valid value is $d_9=1$, not available.
\item $d_7d_8=72$. We need $d_9=8$ and $d_{10}=9$. On the other hand $d_5$ must be $3$. To get a multiple of 3 we need that $\llave{d_3,d_4}=\llave{0,6}$. And $\llave{d_1,d_2}=\llave{1,4}$. This gets us four further solutions. Nice!
\item $d_7d_8=83$. So $d_9=2$ and $d_{10}=3$. Oops.
\item $d_7d_8=94$. $d_9=9$, already used.
\end{itemize}
\item So we already got the $6$ cases and no programming is needed!
\end{itemize}
This is a remarkable problem, in that it can be very easily analysed by hand completely. These are rare, but always fun.

\section{Pentagon numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 5482660. \textit{Solved: Sat, 8 Aug 2015, 21:29}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Another problem that I don't quite like. It's not like it's super slow or anything, but the lack of a proper limit bothers me. Anyway, the steps I followed where these: generate successive pentagonal numbers $p_i$, and for each $j<i$, verify whether $D=p_i-p_j$ is pentagonal (by looking it up in the set of previously generated) and whether $S=p_i+p_j$ is also pentagonal (by checking that $\dfrac{1+\sqrt{24S+1}}6$ is an integer). If both conditions hold, return $D$.

\section{Triangular, pentagonal, and hexagonal}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1533776805. \textit{Solved: Sun, 9 Aug 2015, 09:03}.

\textbf{Math knowledge used}: knowledge about polygonal numbers.

\textbf{Programming techniques used}: none.

Unlike the previous one, this one has room for mathematical analysis (aside from the trivial reversal of the pentagonal formula). The nice thing here, and something that apparently I hadn't realised the first time I solved this, is that every hexagonal number is also a triangular number! If we plug $2n-1$ in the formula of the triangular numbers we get:
\begin{equation*}
T_{2n-1}=\dfrac{\paren{2n}\paren{2n-1}}2=2n^2-n=H_n.
\end{equation*}
So the hexagonal numbers are precisely the odd triangular numbers. This means that we can solve this problem by generating hexagonal numbers and checking whether they are pentagonal. We could also do it the opposite way, but since hexagonal numbers are more spaced than pentagonal ones, by iterating this way we perform fewer checks. The result is $P_{31977}=H_{27693}$, so about one seventh of checks is saved.

\section{Goldbach's other conjecture}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 5777. \textit{Solved: Sun, 9 Aug 2015, 09:12}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

This can be done in several ways. What I did was: I set up a limit ($10^5$, high enough), then I used a sieve to get primes and composites. Then I iterate over all the squares, generating the sums of primes plus doubled squares, and finishing when any odd composite smaller than the current square hasn't been generated.

\section{Distinct primes factors}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 134043. \textit{Solved: Sun, 9 Aug 2015, 09:26}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve for divisor generation.

\textbf{Programming techniques used}: none.

Not much room for finesse aside from generating divisors reasonably cleverly. Just generate the divisors for every number, keeping track of numbers with exactly four different prime factors, and finish when four consecutive ones are found.

By the way:
\begin{itemize}
\item $134043=3\cdot7\cdot13\cdot491$.
\item $134044=2^2\cdot23\cdot31\cdot47$.
\item $134045=5\cdot17\cdot19\cdot83$.
\item $134046=2\cdot3^2\cdot11\cdot677$.
\end{itemize}

\section{Self powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 9110846700. \textit{Solved: Sun, 9 Aug 2015, 09:37}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: binary exponentiation.

For a veteran, this problem is a bit infuriating. This problems seems to lend itself easily to binary exponentiation, BUT since the modulus is greater than $2^{31.5}$, temporary results don't fit into a long. So either you eschew the speed of binary exponentiations or you eschew the speed of primitive longs. Since I had to bit the bullet anyway, I tried both approaches. To my surprise, doing full iterations with longs is faster than binary exponentiation with BigInteger. \textit{And faster than binary exponentiation with longs} (which returns the wrong results anyway), which is extra-surprising. Initially I assumed that this happens because the exponents are very small and because division is much slower than multiplication, but that's not true. The real issue, and this is super-interesting, is that calling code from a different class adds some overhead in terms of time! I knew that Java initialisation could be slow, but a delay of $10$ms for a single added class is much more time than I had thought.

\section{Prime permutations}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 296962999629. \textit{Solved: Sun, 9 Aug 2015, 10:06}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

Not much to describe. Just iterate over all the primes from 1007 to 3339 (ok, this one is not a prime, but it's the upper limit), and for each one, verify whether $p+3330$ and $p+6660$ are also primes and have the same digits in different order. There is a bit of room for finesse, I think, but I haven't thought much about it. The program is super fast anyway.

\section{Consecutive prime sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 997651. \textit{Solved: Sun, 9 Aug 2015, 10:25}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

This is a bit more interesting than it seems, because there is room for improvements. Obviously we need to iterate over sums of primes, and this can be done in several different ways. What I did was: iterate over primes, and then iterate over \textit{upper bounds} for indices in the array of primes. So, for each starting prime I could always start in an upper bound equal to $1$ plus the current upper bound. This sped up the process, and it ensured that every prime found by this method was a suitable candidate and I could update the current maximum length and the current maximum prime.

By the way, 997651 is the sum of $543$ primes, from $7$ to $3931$ included.

\section{Prime digit replacements}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 121313. \textit{Solved: Sun, 9 Aug 2015, 13:03}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: combination generator (with and without repetition).

What's that? A whopping 15\% difficulty rating! Quite the leap! Just joking, this is still pretty easy, but Project Euler is finally starting to be Project Euler. I think I also pulverised my own longest loop header, using a five-level nested loop in a single header:
\begin{itemize}
\item First we iterate by total amount of digits. Which goes from $5$ to infinity (fortunately the solution has just $6$).
\item The second iteration is over the amount of digits present in the ``variable'' group. Thanks to the pigeonhole principle we know that this digit group must have a length multiple of $3$, because otherwise the group of $10$ different candidates will have at least $3$ multiples of $3$ so there will not be $8$ primes.
\item Then we iterate over the \textit{positions} of the variable digits. In the case of the solution, $121313$, this refers to positions $0$, $2$ and $4$, since the primes are $x2x3x3$. We use a combination iterator without repetition for this.
\item Then we iterate over the fixed digits, save for the last one which is a special case. In this case we use a combination iterator with repetition.
\item Finally we iterate over the last digit, which must be $1$, $3$, $7$ or $9$ since we are looking for primes.
\end{itemize}
For each case, we will build the set of possible numbers ($9$ if the first digit is not variable, $10$ if it is) and we return as soon as we generate a set with $8$ or more primes. It's more complicated than most problems so far, but it's also reasonably simple and doable. It's not even optimal and still it has a little more than $50$ lines and runs in $34$ or $35$ milliseconds.

\section{Permuted multiples}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 142857. \textit{Solved: Sun, 9 Aug 2015, 12:33}.

\textbf{Math knowledge used}: infinite decimal period distributions.

\textbf{Programming techniques used}: none.

Uh... what the fuck is this? It can only have a solution. No programming required. I find this easier than problem $1$. You could as well ask me about how much is $1+2$.

\section{Combinatoric selections}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4075. \textit{Solved: Sun, 9 Aug 2015, 13:11}.

\textbf{Math knowledge used}: combinatorial numbers.

\textbf{Programming techniques used}: none.

There are a million (HA!) ways to do this. The one I use is, I think, possibly one of the fastest approaches. I started with a subarray of the combinatorial numbers $\displaystyle\binom{23}k$ for $k\in\corch{0,9}$, and then I iterated for $n\in\corch{24,100}$, generating at each step the subarray of combinatorial numbers that doesn't exceed the limit of one million. This can be done super fast because it's just a bunch of additions, and checking when the last number is going to surpass the limit (so I need to reduce the array) is quite trivial as well. Then, if this array has length $L$, it means that I have $2L$ combinatorials smaller than one million in this line, and so there must be $n+1-2L$ combinatorials \textit{over} a million. Adding this value for each $n$ yields the solution.

\section{Poker hands}
\textbf{Difficulty rating}: 10\%.

\textbf{Solution}: 376. \textit{Solved: Sun, 9 Aug 2015, 23:58}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Is this ugly? Is this beautiful? Not sure, really. It's very tedious because there are a lot of cases, but I think that the concept is reasonably interesting. The first time I read this problem, I did it in diagonal and thought about all the possible combinations in which player 1 wins (this is a challenge! But in the end it's about counting ties, subtracting from $\displaystyle\binom{54}{10}$ and dividing by two). The real problem is way, way less challenging. I have read somewhere that there are people who consider this problem to be very difficult! The only way I can understand this is if they are messing with all the cases, but for me this definitely doesn't qualify as difficult.

This is, so far, the problem which requires the largest code. By a wide margin.

\section{Lychrel numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 249. \textit{Solved: Mon, 10 Aug 2015, 00:09}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Not much to add. There are ways to speed up the process (such as remembering the intermediate number, i.e. if I found the chain $49\rightarrow143\rightarrow484$ when looking for $49$, I shouldn't need to do the calculations for $143$; or noting that any number whose digits are strictly below $5$ will result in a palindrome immediately), but frankly it's not worth the hassle. The procedure is basically described in the problem: iterate, check, return if the last iteration hasn't found anything.

This problem warms my heart a little because it makes me nostalgic of certain very old maths book.

\section{Powerful digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 972. \textit{Solved: Mon, 10 Aug 2015, 00:15}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Another regression to the ``not really Project Euler'' tutorial problems. There seems to be room for improvement by being clever with culling, iterating downwards and returning early, but this doesn't pay much. Since the powers can be reused, speeding up each iteration, in the end it's just better to write the trivial problem: iterate $a$ and $b$ over the range, calculate the current power using $a\times a^{b-1}$ instead of recalculating the result anew each time, get the sum of digits.

\section{Square root convergents}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 153. \textit{Solved: Mon, 10 Aug 2015, 00:20}.

\textbf{Math knowledge used}: continued fractions and convergents.

\textbf{Programming techniques used}: none.

The fun begins! Project Euler still holds your hand, but it's getting ready for the main show. At this point it's reasonably easy to just follow the instructions, and you can even use doubles to get the periodic fraction (which is laughably simple), but since the convergents are going to be used from time to time (yes $192$ and $656$, I'm talking to you) and actual accuracy is required there, let's talk a bit about how to generate the periodic continued fraction of a square root.

The trivial calculations uses double precision without restriction. We define variables $x=\sqrt k$ and $l=\floor{x}$ ($l$ for ``\textbf{l}ast convergent''), and we iterate: at each step, $y=\dfrac1{x-l}$, and then we assign $x\leftarrow y$, $l\leftarrow\floor y$. If we are calculating the period of a square root, we end when we get $l=2\floor{\sqrt k}$ (yes, really). So far so good, right? The problem is that floating point numbers are really crappy, so around $n=130$ you will start getting problems, so a more careful analysis is necessary.

Where to start that careful analysis? It seems clear that both the numerator and the denominator are going to be elements from $\mathbb Q\corch{\sqrt n}$, so we can just model $x$ and $y$ as fractions of the form $\dfrac{A\sqrt n+B}{C\sqrt n+D}$. Let's call the succession of convergents $a_n$, because it will ease the reasoning. So $a_0=\floor{\sqrt n}$ and $a_1=\dfrac1{\sqrt x-a_0}$. Now, the basic iteration calculates the new terms as follows:
\begin{itemize}
\item $A_{n+1}=C_n$.
\item $B_{n+1}=D_n$.
\item $C_{n+1}=A_n-a_nC_n$.
\item $D_{n+1}=B_n-a_nD_n$.
\item $a_{n+1}=\floor{\dfrac{A_{n+1}\sqrt k+B_{n+1}}{C_{n+1}\sqrt k+D_{n+1}}}$.
\end{itemize}
This looks very promising! But... we will encounter precision problems \textit{even a bit before} than with the previous method, because floating point is a bitch. Oh, yes, the values for $A_n$, $B_n$, $C_n$ and $D_n$ will be correct because they use integer arithmetic, by which I mean BigInteger arithmetic. But in order to reduce precision problems regarding $a_n$, we need to rationalise the denominator. So, in order to actually calculate the convergents, we need to change the formula for $a_n$ into this one:
\begin{equation*}
a_n=\floor{\dfrac{\paren{B_nC_n-A_nD_n}\sqrt k+\paren{A_nC_nk-B_nD_n}}{C_n^2k-D_n^2}}.
\end{equation*}

It's a bit soon to write all this since this is not needed at all for problem $57$ (for which we only need to calculate $a_1=2$, which is even given as part of the problem description), but the convergent library is going to be the same for a few problems in the future.

Now, back to problem $57$. Yes, all that shit above doesn't mean much because the succession of terms in the periodic fraction is $a_n=\llave{2,2,2,\ldots}$. Now, how to \textit{really} calculate the convergents? As in, the whole $\dfrac pq$ fractions? The formula is quite simple. We call $a_0=\floor{\sqrt k}$ ($k=2$ in our case) and then $a_n$ starting in $n=1$ is the aforementioned succession. So, we define: $p_{-1}=1$; $q_{-1}=0$; $p_0=\floor{\sqrt k}$, $q_0=1$. The iterative process just follows the formulas $p_n=a_np_{n-1}+p_{n-2}$, $q_n=a_nq_{n-1}+q_{n-2}$. This is the general calculation that will be used often. Now, for problem $57$ specifically, we just need to calculate $\llave{p_n,q_n}$ for $k=2$ and $n\in\corch{1,1000}$ and count in how many cases $p_n$ has more digits than $q_n$. Which is far too simple and can be done using the imprecise double calculations, but then it wouldn't be reusable.

This explanation is too long for problem $57$, yes. However, it's not too long for problems $66$, $192$ or $656$.

\section{Spiral primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 26241. \textit{Solved: Mon, 10 Aug 2015, 10:23}.

\textbf{Math knowledge used}: Erathostenes sieve and Miller-Rabin primality test.

\textbf{Programming techniques used}: none.

Unlike that awful problem 28, this one spirals in the right, positive direction. The problem itself is pretty easy, because we can keep counters for each branch tip: $f_{\llave{1\ldots4}}={3,5,7,9}$ at the start, and then, starting with $i=4$ and in increments of two we can do $f_k=f_{k-1}+i$ (starting with $f_1=f_4+i$) and check primalities as we go.

This problem is the first one where my execution time exceeds half a second ($\approx0.6$s).

\section{Spiral primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 129448. \textit{Solved: Mon, 10 Aug 2015, 10:43}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Easy, but fun. The idea is that the english text will contain the string ``the'' many times. So for each password we will generate the decrypted string, and we will accept the one with the highest amount of appearances of ``the''. In the end, the password is ``exp'' and the text is this paragraph:

\textit{An extract taken from the introduction of one of Euler's most celebrated papers, "De summis serierum reciprocarum" [On the sums of series of reciprocals]: I have recently found, quite unexpectedly, an elegant expression for the entire sum of this series 1 + 1/4 + 1/9 + 1/16 + etc., which depends on the quadrature of the circle, so that if the true sum of this series is obtained, from it at once the quadrature of the circle follows. Namely, I have found that the sum of this series is a sixth part of the square of the perimeter of the circle whose diameter is 1; or by putting the sum of this series equal to s, it has the ratio sqrt(6) multiplied by s to 1 of the perimeter to the diameter. I will soon show that the sum of this series to be approximately 1.644934066842264364; and from multiplying this number by six, and then taking the square root, the number 3.141592653589793238 is indeed produced, which expresses the perimeter of a circle whose diameter is 1. Following again the same steps by which I had arrived at this sum, I have discovered that the sum of the series 1 + 1/16 + 1/81 + 1/256 + 1/625 + etc. also depends on the quadrature of the circle. Namely, the sum of this multiplied by 90 gives the biquadrate (fourth power) of the circumference of the perimeter of a circle whose diameter is 1. And by similar reasoning I have likewise been able to determine the sums of the subsequent series in which the exponents are even numbers.}

\section{Prime pair sets}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 26033. \textit{Solved: Mon, 10 Aug 2015, 12:37}.

\textbf{Math knowledge used}: Erathostenes sieve and Miller-Rabin primality test.

\textbf{Programming techniques used}: dynamic programming/memoisation (sort of).

I find that $20\%$ quite reasonable. It's not like this is a super difficult method, but it's tricky to get it right, there is no obvious solution (no, the solution is not the one for $4$ primes plus an additional one) and getting it efficiently can be a challenge. I used a complicated structure with trees where for each prime I stored possible combinations of less than $5$ primes verifying the conditions. For each prime, and for $n\in\llave{0,3}$, I have a tree storing the combinations including the prime and $n$ additional numbers. So, each time I add a prime, I need to traverse the structure for each prime less than the one given, and if I can traverse successfully a tree of level $3$, then I can add the three associated numbers, plus the prime ``owner'' of the tree, plus the prime we're currently iterating. It's a bit weird but it's efficient and the code is not that complicated.

This is also the first problem where my algorithm took more than $1$ second. A bit more than $5$ seconds, in fact. The final solution is composed of these primes: $\llave{13,5197,5701,6733,8389}$.

\section{Cyclical figurate numbers}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 28684. \textit{Solved: Mon, 10 Aug 2015, 13:34}.

\textbf{Math knowledge used}: polygonal numbers.

\textbf{Programming techniques used}: none.

This is very fast because the obvious way is to start the iterations from the octogonal numbers, since there are fewer of them, and it happens that the octogonal number is the smallest of them all. Although it's not like it would be horribly slow otherwise.

The method is: generate all the triangular, square, pentagonal, hexagonal and heptagonal numbers. You can use a map for each type, or a single map with all the data with a tag indicating the kind of polygonal type. Index the map by the first two digits of the polygonal number. Then, iterate over all the octogonal numbers, and follow a recursive search where at each step you look for the first two digits in the map, which come from the last two digits of the previous number. The search succeeds when all the polygons have been fulfilled and the end digits of the last number are the first ones of the first octogonal number.

This is the chain:
\begin{equation*}
\hspace{-1.5cm}
P_{8,21}=1281\Rightarrow P_{6,64}=8128\Rightarrow P_{5,44}=2882\Rightarrow P_{3,128}=8256\Rightarrow P_{4,75}=5625\Rightarrow P_{7,32}=2512.
\end{equation*}

\section{Cubic permutations}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 127035954683. \textit{Solved: Mon, 10 Aug 2015, 13:57}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Very simple, just use a Multimap-like cache with the digit representation of all the cubes (the key should be a summary of the digits that doesn't take the order into account; an IntIntMap of digit to count of digits is good enough), update it with all the cubes, and stop as soon as the current digit representation has $5$ different values.

The cubes that share the same digits are: $5027^3=127035954683$; $7061^3=352045367981$; $7202^3=373559126408$; $8288^3=569310543872$; and $8384^3=589323567104$.

Updating the code so that we can find the solution for values of $N$ greater than $5$ shows that the solution grows relatively slowly, and the execution time is not preposterous. For example for $N=15$ the cubes are between $47456^3=106874325794816$ and $95636^3=874710238619456$, and the solution is found in less than $15$ seconds (the one for $N=5$ takes a bit more than $0.2$ seconds).

\section{Powerful digit counts}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 49. \textit{Solved: Mon, 10 Aug 2015, 14:08}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Extremely easy. For each amount of digits, $i$, we need to count the values from $1$ to $9$ so that $n^i\geq10^{i-1}$. This means that we need to count values of $n$ greater than $10^{\frac{i-1}i}$. So, for integer values of $i$ starting from $i=1$, add $10-\ceil{10^{\frac{i-1}i}}$, stop when this value reaches $0$. This runs in about a quarter of a millisecond.

Of course, you can always brute force and explicitly generate the numbers, but this method is much more reliable.

\section{Odd period square roots}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 1322. \textit{Solved: Tue, 11 Aug 2015, 00:47}.

\textbf{Math knowledge used}: continued fractions.

\textbf{Programming techniques used}: none.

Oooh! More contiuned fractions. Project Euler still holds your hand, but it forces you to be careful about precision. Anyway, having the PeriodicContinuedFraction class, this is trivial (although I had to add a new method to check the length of the period).

See problem $57$ for a comprehensive description of the method used to generate continued fractions.

\section{Convergents of e}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 272. \textit{Solved: Tue, 11 Aug 2015, 09:44}.

\textbf{Math knowledge used}: continued fractions.

\textbf{Programming techniques used}: none.

My existing implementation of continued fractions only allowed periodic ones, i.e. those which come from square roots. So I created a generic interface to accomodate custom continued fractions, which required remarkably little tweaking in my Convergents.java file. Then, for this problem, I created a new class for the (very simple) continued fraction of $e$, defining only two tiny methods, and the common class did the rest. Hooray!

\section{Diophantine equation}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 661. \textit{Solved: Tue, 11 Aug 2015, 09:46}.

\textbf{Math knowledge used}: continued fractions and its convergents; plus Pell's equation.

\textbf{Programming techniques used}: none.

THIS. This is it. This is the first actual, real, pure, distilled Project Euler problem. This is where Project Euler finally shows its teeth. And this is the first time I hit a wall. Why? Simple. Because the reason why this is the first real Project Euler problem is that this is the first one where no amount of brute force will get you anywhere. To give context: the value of $x$ is $16421658242965910275055840472270471049$. Yes, that's a $38$ digit number. Good luck waiting for the end of the universe while you find that by brute force.

Now, with the help of convergents, the solution is much easier. In order to solve the equation $x^2-Dy^2=1$, you just need to find the convergents for the square root of $D$, and iterate over all of them until you find some $\dfrac{p_i}{q_i}$ so that $p_i^2-Dq_i^2=1$. If you can generate convergents, which you should thanks to the previous problems, then the algorithm is trivial. Of course, you still need to know about Pell's equation. I didn't and that's why I hit a wall. Then I read a hint randomly in another problem's thread (I don't even remember which one). And that's when I realised that Project Euler was much deeper, and much more fun, than I initially had thought. This is, in a very real sense, the problem that got me actually hooked.

\section{Maximum path sum II}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 7273. \textit{Solved: Tue, 11 Aug 2015, 10:22}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: greedy algorithm.

This is the same as problem $18$, only with a bigger size. The only way this would be different is if I had solved $18$ by brute force, which I didn't.

\section{Magic 5-gon ring}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 6531031914842725. \textit{Solved: Tue, 11 Aug 2015, 11:20}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: permutation generator.

I'm very surprised that this problem gets a difficulty rating as high as problem $66$. This one is ultimately a reasonably doable search. I mean, it surely can be done by hand with some work, but I got lazy for this one (didn't feel like a lot of trial and error) and just iterated over all the $10!$ possibilities. It takes about a quarter of a second; it's not like it's terribly complicated.

\section{Totient maximum}
\textbf{Difficulty rating}: 10\%.

\textbf{Solution}: 510510. \textit{Solved: Tue, 11 Aug 2015, 11:34}.

\textbf{Math knowledge used}: Euler's totient function.

\textbf{Programming techniques used}: none.

In hindsight, it's surprising that we need to go as far as problem $69$ to find the first reference to the totient function. In fact, the totient function is not needed at all until now (although the divisor function used in problems $21$ and $23$ is very close). However, from now on it will be used reasonably often. Much more often than convergents, for example.

I can see three approaches to this problem: first, brute force, as in counting the divisors by hand. This is $O\paren{n^2}$ and therefore it's not really bruteforceable, which I guess is why the difficulty rating is $10\%$ and not $5\%$. Second, ``kind of'' brute force, that is, calculating $\dfrac n{\varphi\paren n}$ for all $n$ and taking the maximum. This is much more reasonable (and this is how I solved this for the first time), but then there is the much better third approach, which I'll explain in the next paragraphs.

So, the totient function is multiplicative. This means that if $\mathrm{gcd}\paren{m,n}=1$, then $\varphi\paren{mn}=\varphi\paren m\varphi\paren n$. In particular, if the prime decomposition of $n$ is
\begin{equation*}
n=\prod_ip_i^{e_i},
\end{equation*}
where $p_i$ are prime factors each raised to the $e_i$-th power, then
\begin{equation*}
\varphi\paren n=\prod_i\varphi\paren{p_i^{e_i}}.
\end{equation*}

Also, for any prime $p$ we have $\varphi\paren{p}=p-1$ and $\varphi\paren{p^n}=\paren{p-1}p^{n-1}$ (note that these formulas alone are enough to calculate the totient of any number, given its prime decomposition). Now, all this means that
\begin{equation*}
\dfrac n{\varphi\paren n}=\dfrac{\prod_ip_i^{e_i}}{\prod_i\paren{p_i-1}p^{e_i-1}}=\dfrac{\prod_ip_i}{\prod_ip_i-1}=\prod_i\dfrac{p_i}{p_i-1}.
\end{equation*}
This is super useful because it means that the quotient we are looking for depends on just the prime factors present on the number, not on their multiplicity. Now, there is something even better: the quotient $\dfrac p{p-1}=1+\dfrac1{p-1}$ is a decreasing function in $p$, which means that smaller primes beget bigger quotients. Since each factor is bigger than $1$, it's clear that what we want to do is cramming as many primes as possible, and as small as possible. So: the solution to this problem is the product of the $N$ smallest primes (this is called a primorial), but we can't exceed one million. That is, the solution of this problem is the biggest primorial that doesn't exceed one million. Which is $2\cdot3\cdot5\cdot7\cdot11\cdot13\cdot17=510510$. Of course, multiplying this number times any $17$-smooth number will result in the same $\dfrac n{\varphi\paren n}$ quotient, but since $2\cdot510510>10^6$, there aren't any other numbers smaller than a million with the same quotient, and therefore $510510$ is the solution.

\section{Totient permutation}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 8319823. \textit{Solved: Tue, 11 Aug 2015, 11:55}.

\textbf{Math knowledge used}: Euler's totient function.

\textbf{Programming techniques used}: none.

Unlike in the previous case, we want to maximise the quotient, so we need few primes and as big as possible. However:
\begin{itemize}
\item The result can't be a prime because $p$ and $p-1$ will never be an anagram.
\item It also can't be $p^2$ because if $p$ is prime then $\varphi\paren{p^2}=p^2-p$ and since $p$ is not a multiple of $9$ then $p^2\not\equiv\varphi\paren{p^2}$ (mod $9$), so $p^2$ can't be an anagram of $\varphi\paren{p^2}$.
\item Then, ideally the result is the product of two primes. This is not \textit{strictly} true, but it's a very good heuristic; we can assume it and in this problem it gets the correct solution.
\end{itemize}
The obvious solution is to iterate over pairs of primes, but we can trim the search space even more. The properties of anagrams imply that, if our solution is $pq$, then $pq\equiv\paren{p-1}\paren{q-1}$ (mod $9$). Now this means that (excluding the case $p=3$, not important since $3$ is very small), if any of the primes is of the form $3k+1$, then $\varphi\paren{pq}$ is a multiple of $3$ and therefore it can't be an anagram of $pq$, which is not a multiple of $3$. This removes a lot. And now that we know that $p,q\equiv2$, $5$ or $8$ (mod $9$) we can analyze the six possibilities:
\begin{itemize}
\item $p\equiv2$, $q\equiv2$. Then $pq\equiv4$, $\varphi\paren{pq}\equiv1$.
\item $p\equiv2$, $q\equiv5$. Then $pq\equiv1$, $\varphi\paren{pq}\equiv4$.
\item $p\equiv2$, $q\equiv8$. Then $pq\equiv7$, $\varphi\paren{pq}\equiv7$.
\item $p\equiv5$, $q\equiv5$. Then $pq\equiv7$, $\varphi\paren{pq}\equiv7$.
\item $p\equiv5$, $q\equiv8$. Then $pq\equiv4$, $\varphi\paren{pq}\equiv1$.
\item $p\equiv8$, $q\equiv8$. Then $pq\equiv1$, $\varphi\paren{pq}\equiv4$.
\end{itemize}
So the only valid cases are the pairs $\llave{2,8}$, $\llave{5,5}$ and $\llave{8,2}$. This is really neat. This means that not only we can discard a lot more, but that we can just look for products of the form $pq\equiv7$. In fact: take the initial code, add two additional control sentences ($p\equiv2$ mod $3$ and $pq\equiv7$ mod $9$) and the run time speeds up from $0.56$s to less than $0.23$s. And that's even being conservative and ``wasteful'' and starting from $p=2$ instead of a much higher prime. The result, in fact, is $2339\cdot3557$.

\section{Ordered fractions}
\textbf{Difficulty rating}: 10\%.

\textbf{Solution}: 428570. \textit{Solved: Tue, 11 Aug 2015, 12:03}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Once you see the solution, it's kind of obvious, considering that $3/7=428571/999999$, isn't it? But there is a formal process that can reliably get the solution for any random fraction. The obvious solution is to take, for every denominator $d$, the numerator $\ceil{\dfrac{3d}7}-1$, calculate the difference and store the best one. But there is a better way: we can iterate downwards, and once we get a suitable value, we can aggresively trim the search space. ACHTUNG! The following analysis is basically lifted from the problem overview from the Project Euler page.

So, let's suppose that we have a current solution $\dfrac pq$. We are looking for a hypothetical fraction $\dfrac rs$ so that $\dfrac ND-\dfrac rs>\dfrac ND-\dfrac pq$. We can operate like this:
\begin{equation*}
\dfrac ND-\dfrac rs=\dfrac{Ns-Dr}{Ds}\geq\dfrac1{Ds}.
\end{equation*}
Therefore we are looking for denominators $s$ that verify that
\begin{equation*}
\dfrac1{Ds}<\dfrac{Nq-Dp}{Dq}\Rightarrow s>Nq-Dp.
\end{equation*}
It might not look like it, but this is actually awesome because it trims the search space really, really fast. And even better, if you hit $Nq-Dp=1$ then it's guaranteed that the next iteration will finish. And yes, this does happen in this problem.

This additional analysis is not super necessary, because the obvious program is already very fast. But it speeds up the program, from more than $20$ms to less than a quarter of a millisecond.

\section{Counting fractions}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 303963552391. \textit{Solved: Tue, 11 Aug 2015, 12:15}.

\textbf{Math knowledge used}: sum of totients function.

\textbf{Programming techniques used}: none.

Super high level magical function to the rescue!

This is very easy if you have the proper tools. Now, admittedly, I didn't have this function until much later, and the first time I solved this problem, I just added the totients. However, this is \textit{so much} faster that I must accept it as the proper way.

So, for each denominator $d$, the proper fractions $\dfrac nd$ are those for which $\mathrm{gcd}\paren{n,d}=1$. Of course we know that $\varphi\paren n=\#\llave{d\in\corch{1,n}:\mathrm{gcd}\paren{d,n}=1}$, so this problem is as simple as calculating
\begin{equation*}
\sum_{n=2}^{1000000}\varphi\paren n.
\end{equation*}
Now, we can calculate all the totients and add them. But there is a wonderful magical way of calculating the sum of totients directly, with an algorithm whose run time is about $O\paren{N^{2/3}}$ (the trivial one would be about $O\paren{N\log N}$, much slower). This algorithm works in a more or less similar way than the also magical ``sum of primes'' algorithm that Lucy\_Hedgehog gracefully bestowed us in the comments of Euler10. I have used this sum of totients algorithm in a few places, and the full description can be found at the link in the comments of the SumOfTotientCalculator class.

Now, this wonderful function returns $\displaystyle\sum_{n=1}^L\varphi\paren n$, so we need to subtract $\varphi\paren1=1$ to get the final result. But no additional work is needed.

\section{Counting fractions in a range}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 7295372. \textit{Solved: Tue, 11 Aug 2015, 13:25}.

\textbf{Math knowledge used}: Farey sequences and Stern-Brocot trees.

\textbf{Programming techniques used}: none.

Well. The overview for the problem uses a more complicated structure and gives an algorithm that I swear I've tried, noting that it \textit{doesn't} return the actual solution. Farey sequences are generated like this: if you have $\dfrac ab$ and $\dfrac cd$, the middle term is $\dfrac{a+c}{b+d}$; and Stern-Brocot trees go like this: now that you have these three fractions, repeat the procedure, this time using both $\llave{\dfrac ab,\dfrac{a+c}{b+d}}$ and $\llave{\dfrac{a+c}{b+d},\dfrac cd}$ as limits. This lends naturally to a recursive approach that doesn't work very well because the recursion level is too deep, so I used an explicit stack.

Honestly, Stern-Brocot trees are not that much faster than the obvious approach (iterate denominator from $4$ to $L$; for each one, iterate numerator between $\floor{\dfrac d3}+1$ and $\ceil{\dfrac d2}-1$, included; increase a counter if $\mathrm{gcd}\paren{n,d}=1$). But at least it is faster. I assume that the alternate approaches described in the problem overview would be much faster. If they worked...

\section{Digit factorial chains}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 402. \textit{Solved: Tue, 11 Aug 2015, 14:33}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: memoisation.

I'm completely baffled by the results I got from this. Not about the result per se, but about the time. Initially I copied my old C++ implementation. It uses a cache for the next number at each step, an int array of length $9\cdot9!$. Super slow. Ok, let's be clever and find the highest number that does get visited. It's something like $2170000$. Let's use the cache just up to that number. $33$ seconds, $32$ of which go to the initialisation? WOW. What if I used an IntIntMap (i.e. a lazy cache)? Down to less than $1.5$ seconds. This is pretty crazy. Hail IntIntMap.

In the Project Euler forums there are people following clever combinatorial schemes (like, if you find that $1479$ has a chain of $60$, then so does $4971$, and so on). I didn't trust this because I couldn't be sure that permutations aren't fucking with the chains (i.e. if the chain for $1479$ repeats because it eventually gets to $4971$, then the chain for $4971$ doesn't have $60$ elements, but $59$). The brute-forcish approach still gets the result in $1.5$ seconds so it's good enough.

\section{Singular integer right triangles}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 161667. \textit{Solved: Tue, 11 Aug 2015, 14:37}.

\textbf{Math knowledge used}: Pythagorean triples generation.

\textbf{Programming techniques used}: none.

Oh, come on! How does this have the same difficulty as the mythical problem 66? Ahem.  So, just generate all the triples, and for each one, increase a counter for every multiple of the perimeter found. That is, for $\paren{3,4,5}$ the perimeter is $12$ so we would increase a counter for $12$, $24$, $36\ldots$ Similar to Erathostenes sieve. Then iterate over the counters and note how many of them have been increased exactly one time.

\section{Counting summations}
\textbf{Difficulty rating}: 10\%.

\textbf{Solution}: 190569291. \textit{Solved: Tue, 11 Aug 2015, 14:54}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Classic dynamic programming problem. Very similar to the one about the pounds.

\section{Prime summations}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 71. \textit{Solved: Tue, 11 Aug 2015, 15:23}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: dynamic programming.

Very similar to the previous one, with a small twist. Still calculated with a 2D array, but in this case the rows use an increment equal to a prime number, instead of having a constant difference of 1.

\section{Coin partitions}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 55374. \textit{Solved: Tue, 11 Aug 2015, 16:26}.

\textbf{Math knowledge used}: partition function, generalised pentagonal numbers.

\textbf{Programming techniques used}: memoisation.

No wonder this has a whooping $30\%$ difficulty rating: this can't be done using brute force, plus the formula to calculate the result is, well, relatively obscure. In a sense, this is the opposite of problem 66: for that one, the previous problems were centered about a technique (continued fractions and convergents) that appeared to be unrelated but ended being fundamental to the solution. In this case we have the opposite: leading problems that seem to be similar, but then the knowledge required for this one changes completely. To be fair, dynamic programming could work, but it's harder to get it right, especially considering that there is no limit. However, there is a formula using generalised pentagonal numbers, which is what I used.

The formula is the following: if $P\paren n$ are the partitions of $n$, then:
\begin{equation*}
P\paren n=\left\{\begin{array}{ll}n<0:&0;\\n=0:&1;\\\mathrm{ otherwise}:&{\displaystyle\sum_{k=1}^\infty}\paren{-1}^{k-1}\paren{P\paren{n-\frac{k\paren{3k-1}}2}+P\paren{n-\frac{k\paren{3k+1}}2}}.\end{array}\right.
\end{equation*}
The values $\dfrac{k\paren{3k\pm1}}2$ are those ``generalised pentagonal numbers''. In the end the algorithm has about order $O\paren{n^{3/2}}$ where $n$ is the solution (that sum up to infinity is misleading. When $n$ minus the generalised pentagonal is smaller than $0$, we stop), so it's a bit slow, but still, a third of a second is not too slow.

\section{Passcode derivation}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 73162890. \textit{Solved: Tue, 11 Aug 2015, 16:37}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I have done this by hand in the past, but this time, I felt like writing a program. I actually worked with characters, not with numbers; in fact there is nothing actually mathematical, or arithmetical, about this problem. So, for each character $c$ I kept the list of all the characters that must precede $c$ in the password. This creates a map from character to set of characters, which I then iterate over, choosing at each time any character who has had all its prerequisites already fulfilled (note that this implies that we will create an empty map for the initial character). Runs in about $0.08$ seconds, much more than I had imagined, maybe because the I/O and because of the repeated additions to the maps.

\section{Square root digital expansion}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 40886. \textit{Solved: Tue, 11 Aug 2015, 16:44}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I can't fucking believe that this program is rated $20\%$. A lot of maths-oriented or otherwise high level programming languages offer arbitrary precision decimals as a basic feature, so I expected most people to solve this using a lazy predefined call.

What I did was the following: for each number $A$, at each time I have an approximation of the square root as a fraction: $\sqrt A\approx\dfrac nd$. This means that $\abs{\sqrt A-\dfrac nd}<1$, meaning that if I square the left term, I will get something in the range $\corch{0,1}$, and with a smaller absolute value, i.e., reducing the error. So the next approximation comes from this:
\begin{equation*}
\paren{\sqrt A-\dfrac nd}^2\approx0\Rightarrow A-\dfrac{2n\sqrt A}d+\dfrac{n^2}{d^2}\approx 0\Rightarrow\sqrt A\approx\dfrac d{2n}\paren{A+\dfrac{n^2}{d^2}}=\dfrac{Ad^2+n^2}{2nd}.
\end{equation*}
When do we need to stop iterating? Ok, let's be a bit clever. Let's say that $x=\floor{\sqrt A}$. If, say, $A=\paren{x+1}^2-1$, then $\sqrt A-x$ is almost 1, so by squaring it we get something that is also close to $1$, i.e. the iterations will converge slowly. Not good. In this case, we would be much better served by starting with $x+1$. In fact, it's quite easy to see that there is some value $y\in\paren{x^2,\paren{x+1}^2}$ so that for smaller values we should use $x$ as first approximation, and for bigger values we should use $x+1$. The tipping point should be around $\paren{x+0.5}^2=x^2+x+0.25$. Well, simple enough, right? This suggests the usage of $\floor{\sqrt A}=x$ if $x\paren{x+1}\leq A$, and $\ceil{\sqrt A}=x+1$ otherwise. This guarantees that $\abs{\sqrt A-x}<\dfrac12$, which is wonderful because at each step we square that error. This means that after $n$ steps the error is $\dfrac1{2^{2^n}}$. We need this to be smaller than $10^{-100}$, so
\begin{equation*}
2^{2^n}>10^{100}\Rightarrow2^n\log2>100\log10\Rightarrow n>\log_2\paren{100\log_210}.
\end{equation*}
Since $\ceil{\log_2\paren{100\log_210}}=8$, that's the amount of iterations to use.

\section{Path sum: two ways}
\textbf{Difficulty rating}: 10\%.

\textbf{Solution}: 427337. \textit{Solved: Tue, 11 Aug 2015, 22:05}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

This is basically a rehash of problems $18$ and $67$. The minimal path to each point equals the value of the current cell, plus the minimum of the minimal paths to the cells directly up and to the left.

\section{Path sum: three ways}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 260324. \textit{Solved: Tue, 11 Aug 2015, 22:24}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

The approach is basically the same as in the previous case, but column by column. We start by initialising the first column, then for each one of the following, we initialise the values with the sum to the left plus the value in this cell, and then we follow an iterative process where each cell can be updated with the contents directly upwards or downwards (plus the current cell value, of course) if that's less than the current sum. It finishes quickly, in about $50$ms.

Also, it appears that the file for this problem is the same one as the previous one.

\section{Path sum: four ways}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 425185. \textit{Solved: Tue, 11 Aug 2015, 23:08}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

The approach for this problem mixes the one from the two previous ones. First we initialise the 2D matrix with blatantly copypasted code from problem 81 (this provides a sensible first approximation using dynamic programming), and then, for each cell in the whole matrix, we try to update the current value with its four neighbours, same as in the previous problem (where only three were used). And we finish when a whole iteration doesn't update any value.

Again, the in file is the same as in the previous problems.

\section{Monopoly odds}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 101524. \textit{Solved: Tue, 11 Aug 2015, 22:45}.

\textbf{Math knowledge used}: Markov chains, linear algebra.

\textbf{Programming techniques used}: none.

Yeah, this is one of those cases where the basics are reasonably easy to get right, but the details can be tricky. So tricky that I strongly suspect that \textit{I actually got the problem wrong} despite getting the right result. That $35\%$ is totally warranted, and there is good reason for this problem to be one of the most difficult from the first $100$.

The analysis starts from a transition matrix. In order to generate the transition matrix, one must start from the ``dice'' transition. This is a map that, for each possible amount of squares, calculates the probability of moving exactly that amount. In the case of standard dice, we have $\dfrac1{36}$ probability to move $2$ squares, $\dfrac1{18}$ to move $3$ squares, and so on. With this is mind, the first matrix is filled like this: for each row $i$, the square $i+j$ is set to the probability of moving $j$ squares (apply mod $40$ when necessary). And after this we apply the special conditions, which are a bit of a bitch because they must be applied in certain specific order. Specifically, ``chance'' must be applied before ``community chest'' because there is a possibility that you get the second after the first makes you go back three squares. Side note, I'm pretty sure that I must have botched something here but I don't know what.

So we have the transition matrix $M$. The Markov chain theory says that the vector of steady state probabilities, which is what we want, verifies $x^TM=x^T$. That's slightly unusual, but if we transpose the matrix, we get $M^Tx=x$. Which means $\paren{M^T-I}x=0$. That's good, except for the problematic fact that this is an indeterminate system (specifically, $M^T-I$ is singular). We want a particular solution that verifies $\sum_ix_i=1$, but we can get it from any solution that verifies $\sum_ix_i\neq0$. Then, we force the last member of $x$ to $1$, and by doing that we transform the equation into $M'x'=v$, where $M'$ is the result of removing the last row and last column of $M^T-I$, $x'$ is $x$ without the last element, and $v$ is the remainder after assigning $x_{40}=1$: the last column of $M^T-I$ (minus the last element), negated.

Finally, the equation $M'x'=v$ is solvable, and yes I used gaussian elimination in Java because why not. So we get the solution $x'$, append the $x_{40}=1$, and divide by $\sum_ix_i$ to get a normalised solution. Then we search for the three squares with highest probability, and done.

Now, this gets me the right solution for both the $6$-sided case ($102400$) and the $4$-sided case ($101524$). So far so good. However, the probabilities I'm getting are NOT the same that the problem gives. I'm sure it has to do something with the fucking ``3rd double, go to jail'' rule (which I didn't expect to be meaningful), but that would require a more complicated analysis and frankly I'm not bothering. The analysis, roughly, would require a $120\times120$ matrix, and the current state would be determined by the pair (current square, amount of doubles). The solution would require some additional post-processing in order to condense the three instances of each square in the final vector.

UPDATE: it wasn't so complicated to solve the $120\times120$ problem. I'm getting the right probabilities for the $6$ sided dice (although I would have normalized the $3.095\ldots$ for the $00$ square as $3.10$, not $3.09$. Perhaps this is still wrong?), and the least probable square, barring the impossible square $30$, is square $07$ with a measly $0.86\%$ probability; the least probable non-card square is square $01$ with a probability of $2.13\%$. And for $4$ sided dice I'm getting these results:
\begin{itemize}
\item $P=7.02\%$ for square $10$.
\item $P=3.62\%$ for square $15$.
\item $P=3.29\%$ for square $24$.
\item The fourth most probable square is square $16$ with $P=3.22\%$.
\item The least probable square (except the trivial $P\paren{30}=0\%$) is square $07$ with $P=0.775\%$.
\item The least probable non-card square is square $01$, with $P=1.76\%$.
\end{itemize}

\section{Counting rectangles}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 2772. \textit{Solved: Tue, 11 Aug 2015, 23:20}.

\textbf{Math knowledge used}: triangular numbers.

\textbf{Programming techniques used}: none.

This is much easier than the previous one. The trick here is that the sides of the rectangle can be counted ``orthogonally''. That is: given a rectangle with $R$ rows, independently of the columns, we will have $R$ combinations which are one row thick, $R-1$ combinations which are two rows thick, and so on, up to $1$ combination with all the rows. And for the columns we have the same, orthogonal to the rows. This means that we have $T\paren RT\paren C$ cases, where $T\paren i$ denotes the triangular number $i$. This means that we can iterate over triangular numbers, looking for the best approximation product.

The best way to iterate is this: iterate over one dimension, from $1$ to $\infty$. For that dimension, get the closest triangular index, $k=T^{-1}\paren{\floor{\dfrac{2000000}{T\paren i}}}$ (where $T^{-1}\paren i=\floor{\dfrac{-1+\sqrt{8i+1}}2}$ is the inverse triangular number function), and iterate from $k$ up to the first value $l$ so that $T\paren iT\paren l$ exceeds $200000$. Which should be about $2$ values of $k$ for each $i$, i.e. very fast.

We only need to iterate up to $i=53$ since $T\paren{53}^2>2000000$. The best solution is found for a $36\cdot77$ rectangle, because $T\paren{36}=666$ and $T\paren{77}=3003$, giving an area of $1999998$.

\section{Counting rectangles}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 1818. \textit{Solved: Tue, 11 Aug 2015, 23:31}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Given three lengths, $x$, $y$, $z$, we are looking for the point $p$ that minimises the sum of $\sqrt{x^2+p^2}+\sqrt{\paren{y-p}^2+z^2}$. There's no need to derive! By ``folding'' the side where the middle intersection point is, so that both sides become a plane, it can be seen that the three possible minimal paths will be $\sqrt{a^2+\paren{b+c}^2}$ where $\paren{a,b,c}$ are the sides in no particular order. It can be proven that the shortest route appears when $a=z$ (assuming $x\leq y\leq z$), and this gives enough information to create an algorithm: we iterate from $z=1$ upwards, and then we use a variable for $x+y$. We iterate that from $2$ to $2z$, and if $z^2+\paren{x+y}^2$ is a perfect square, then we can count $\floor{\dfrac{x+y}2}$ solutions if $x+y<z$, or $\floor{\dfrac{z+2-\paren{x+y}}2}$ otherwise. We keep counting until for some $z$ we exceed the count of one million, and then we return $z$.

As a further optimisation, we can start iterating $z$ from $3$ and $x+y$ from $4$, since there are no pythagorean triangles whose sides are smaller than $3$.

\section{Prime power triples}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 1097343. \textit{Solved: Tue, 11 Aug 2015, 23:44}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I can't believe that this has a $20\%$ rating. I assume that people started deserting once they thad to battle with $66$ or $84$. So: generate primes up to $\sqrt L$. Generate their squares, their cubes and their fourth powers (in each case, stop when you get to $L$). Then use a doubly nested loop (i.e. three levels) to sum squares, cubes and fourths. Use a set or a boolean array, whatever you prefer. Then count the size of the set and/or the amount of set numbers in the array. End! Very easy.

\section{Product-sum numbers}
\textbf{Difficulty rating}: 40\%.

\textbf{Solution}: 7587457. \textit{Solved: Tue, 11 Aug 2015, 23:49}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

I don't quite agree with the difficulty rating: this is the highest rated problem from the first $100$ ($40\%$ is shared with $90$, but this one solved by fewer people), and I don't think it's that complicated, but then again, that might be my years of experience talking.

The gist of the problem is: we need to find all the decompositions of natural numbers as a product of numbers greater than $1$ (for example, for $12$ we have $2\cdot2\cdot3=2\cdot6=3\cdot4=12$; four decompositions, because yes, we include $\llave{12}$, which won't be used to generate candidates but is needed as a base for multiples of $12$). Now, for each decomposition we can add as many ones as we please. So, if we take (say) the case of $2\cdot6$, since the sum of these factors is $8$ (note that as long as there are two or more factors, and they are greater or equal than $2$, the product will always be higher than the sum, so we will add a positive amount of ones), we can add four ones and we will get a decomposition of $1\cdot1\cdot1\cdot1\cdot2\cdot6$, where the factors sum $12$. In general, if we have a list of $k$ factors whose product is $n$ and whose sum is $s$, we can add $n-s$ ones, so that the product is still $n$ (of course), the sum of the factors is now $\paren{n-s}+s=n$, and the final amount of factors is $k+n-s$. So far so good. This gives us a suitable candidate, $n$, for the case for $k+n-s$ factors.

Now, it's not like this is super complicated, but you need to be a bit careful to get it right: to ensure that you always get the minimum $n$ for each $k+n-s$, the best way is to iterate using increasing values of $n$, and fill any structure that verifies that numbers are not fulfilled twice (I used a boolean array and a counter with the amount of pending values). So, the code iterates for all the numbers from $n=4$, and for each one, calculates the decompositions (using a bit of dynamic programming, i.e. reuse of previous solutions to speed up calculations), and finds suitable decompositions for which $k+n-s$ hasn't been fulfilled yet. Storing the results in a set, and adding all its contents at the end, gets the solution. The run time is kind of high (about $0.6$ seconds) but it's still very reasonable.

By the way, the highest number needed is as low as $12200$. Needed for the case $11944$, coming from the decomposition $5, 10, 244$, plus $11685$ ones.

\section{Roman numerals}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 743. \textit{Solved: Wed, 12 Aug 2015, 09:57}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I expected this to be as tedious as $17$, but it was in fact much simpler. Since we have the guarantee that characters are going to be repeated only as much as four times, we can enumerate a very short list of potentially problematic strings, and scan each input for all of them. Each one of the six problematic strings is reduced to a string of two characters, so each time we find one of them we add its length minus two to the result. The only special care needed is to ensure that, say \textbf{IIII} is not counted if \textbf{VIIII} has been already found. Replacing each problematic string with ``\_'' after each find is good enough.

\section{Cube digit pairs}
\textbf{Difficulty rating}: 40\%.

\textbf{Solution}: 1217. \textit{Solved: Wed, 12 Aug 2015, 10:16}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: combination generation (without repetition).

My trusty CombinationIterator class saves the day again. There are only $\displaystyle\binom{10}6=210$ possible dice, so we only need to test $\dfrac{210\cdot209}2=21945$ pairs of dice. And no, the two dice can't be the same, since in that case we will have at most seven different digits, but there are nine digits requiring display. Pigeonhole principle and all that shit. Once we have all the dice, the only remote difficulty is to take care of the $6$ and $9$. A custom ``contains'' function does the trick. The code is supersimple and, aside from the CombinationIterator class, about 50 lines of overengineered code return the right solution in $0.1$ seconds. $40\%$ my ass.

\section{Right triangles with integer coordinates}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 14234. \textit{Solved: Wed, 12 Aug 2015, 23:07}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I dislike this problem, but maybe it's just me. This is about enumeration, and the only tricky part is to ensure that you haven't missed any case. Fortunately this is not too tedious, since there are only three cases and they are simple to get:
\begin{itemize}
\item Right angle at $\paren{0,0}$. Any pair of vertices $\paren{0,x}$ and ${y,0}$ with $x,y>0$ fit the bill. So if $X$ and $Y$ are the maximum values allowed for $x$ and $y$ respectively, we can add $XY$ to the counter.
\item Right angle in the $X$ or $Y$ axis. These are symmetric cases of the previous case. Each axis allows $XY$ additional cases.
\item Right angle at some point $\paren{x,y}$ with $x,y>0$. One cathetus goes from $\paren{0,0}$ to $\paren{x,y}$, and the other cathetus must be orthogonal to this one. So: each lattice point $\paren{x',y'}$ in an orthogonal line to the first cathetus that crosses the $\paren{x,y}$ point generates a triangle. To look for these triangles, first we calculate $g=\mathrm{gcd}\paren{x,y}$ and then we set $i_x=\frac xg$, $i_y=\frac yg$. Then the lattice points are of the form $\paren{x\pm ni_y,y\mp ni_x}$ for as big a value of $n$ we can use without crossing the limits of the $\paren{0,X}\times\paren{0,Y}$ square. That's it.
\end{itemize}
My first run time was $0.036686868$ seconds and I find it funny because I'm very simple.

\section{Square digit chains}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 8581146. \textit{Solved: Wed, 12 Aug 2015, 23:17}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: memoisation.

As the difficulty rating suggests, this is indeed at the level of the first $50$ problems. Use an array up to ten million, and for each number, store either 1 or 89 (use 0 to indicate that it's not set yet). Then use a recursive function that calculates the value as: if it's set in the array, return immediately; otherwise, get the next value in chain, call the recursive function to get the value, store it and return.

\section{Arithmetic expressions}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 1258. \textit{Solved: Thu, 13 Aug 2015, 00:39}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: combination (with repetition) generation, variations (with repetition) generation.

This can be a bitch. Getting a working prototype takes a bit of work, but it can be done (iterate over possible combinations of numbers, iterate over possible combinations of operations, and don't forget to iterate over possible orderings). But getting the details right is tricky, hence that $35\%$ for a relatively simple brute force problem. Rational numbers are needed because at some point you will need to ensure that the operation $\paren{\dfrac12+5}8$ is calculated, meaning that $\dfrac12$ and $\dfrac{11}2$ will need to be stored. Also, depending on how you manage the ordering, you might need explicit ``reverse subtraction'' and ``reverse division'' since these operations are not commutative. You can either use these or use some scheme of parentheses application (which ends being more costly since commutative operations are checked in both directions).

Once you have everything rightly defined, just iterate: for every combination of digits, for every combination of orderings, for every combination of operations: calculate and store all the generated numbers. Then loop over the generated set until a number is missing. The result is the set of digits for which the smallest missing number is the highest. It happens to be $\llave{1,2,5,8}$, which can generate everything up to $44=\paren{\dfrac12+5}8$.

\section{Almost equilateral triangles}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 1258. \textit{Solved: Thu, 13 Aug 2015, 00:57}.

\textbf{Math knowledge used}: Pythagorean triples generation.

\textbf{Programming techniques used}: none.

Yep, Pythagorean triples, since an ``almost equilateral'' triangle can be built by juxtapositioning two identical right triangles. Now, this is pure, distilled Project Euler: just by iterating over Pythagorean triples will not get you much information, but if you run a lot of simulations you will see a pattern appearing. In this case, the pattern I found (\textit{side note: of course there is a better way to do this. But this is \textbf{my} solution}) is: we are generating triples starting from $m$ and $n$, right? (as in: $a=m^2-n^2$, $b=2mn$, $c=m^2+n^2$). Here it is: for a given $m$ or $n$, there are three other values of $m/n$ that generates a valid triangle: one is lower, the other is higher than this one but not higher than its double, and the third one is more than twice this last one. AND! This last number we found is exactly the one we need to use as a base for iterations in the next search.

Yes, this is weird, but it works. And it's fast (about $16$ms). Of course, in the problem thread you see a lot of alternative solutions, but I'm happy because quite a few of them are considerably slower than mine. Others are even faster, of course...

\section{Amicable chains}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 14316. \textit{Solved: Thu, 13 Aug 2015, 11:23}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve for divisor generation.

\textbf{Programming techniques used}: none.

I'm not sure if there is a better way to do this than with brute force, but well, less than $1$ second is always a good time. In about $0.8$ seconds, my program generates the divisor list for all the numbers up to one million, storing it in an array and looking for chains. When a long chain is stored, I store the minimum (which coincidentally is the number we're iterating over). Also, all the numbers from a chain are marked as ``visited'' so that they aren't iterated over again.

The longest chain has a length of $28$ and the highest number is $629072$.

\section{Su Doku}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 24702. \textit{Solved: Thu, 13 Aug 2015, 11:26}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: arc consistency.

For something that I've written so much times, this Sudoku solving algorithm sure gave me a lot of headaches. From very subtle errors after translating my old C++ code, to other very subtle errors detecting inconsistencies in half solved puzzles. Anyway the final algorithm is reasonably fast, with a run time of $0.3$s, give or take, which means a nice average of about $5$ms per Sudoku. Surely there are faster ways to do this, but I'm happy with my result.

\section{Large non-Mersenne prime}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 8739992577. \textit{Solved: Thu, 13 Aug 2015, 11:35}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: binary exponentiation.

Very stupid, streamlined problem. I hate that the mod is so big that BigInteger is required (it was either that or calculating the power linearly instead of with binary exponentiation). Fortunately, modular binary exponentiation is very fast and BigIntegers won't grow much because $20$ digits is the highest amount needed during the calculations. So this gets solved in abot $2$ms.

Save for $206$, which we aren't going to tackle for a while, this is the last problem with $5\%$ difficulty.

\section{Anagramic squares}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 18769. \textit{Solved: Thu, 13 Aug 2015, 11:42}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

After spending a good 10 minutes debugging, I found what might be my most stupid error ever. Instead of calling pow(10,n-1) I was calling pow(10-1,n), thus calculating $9^n$ instead of $10^{n-1}$. Incredibly stupid but also very funny.

So: for each one of the words provided, I generated a multiset with its digits, AND with that multiset I generated a set of the repetition patterns (i.e. for 698896 I would generate the pattern $6,6,8,8,9,9$ and then $2,2,2$; for $59049$ I would generate $0,4,5,9,9$ and then $1,1,1,2$; and so on). So I had two tables where the first key was the repetition pattern (note that this needs to match between the string and the number), the second key was the actual pattern (a multiset of either characters or digits) and the value was a list of strings or numbers. Generating these data structures takes by far most of the time, but matching them is almost instantaneous, since we can group the matches by the repetition patterns, and there aren't many matches. Matching the strings and the numbers is a bit tricky but not super complicated.

There is a grand total of \textit{one single anagram match} in the whole set: BOARD $\Leftrightarrow17689$, BROAD $\Leftrightarrow18769$. The run time is a bit less than $0.6$ secs. The initial structure generation takes easily something like $95\%$ or more of that time.

By the way, the input file for this problem is exactly the same as for problem 42.

\section{Largest exponential}
\textbf{Difficulty rating}: 10\%.

\textbf{Solution}: 709. \textit{Solved: Thu, 13 Aug 2015, 11:51}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Another incredibly easy one for the last problem with a two digit index. If a line is $a,b$ then its numeric value is the usually untractable $a^b$, but its logarithm is the pitifully small $b\log a$. The max value is found for $895447^{504922}$, whose logarithm is $6919994.617152235$ and whose numeric value I'm not going to bother calculating.

\section{Arranged probability}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 756872327473. \textit{Solved: Thu, 13 Aug 2015, 12:37}.

\textbf{Math knowledge used}: Diophantine pairs.

\textbf{Programming techniques used}: none.

Let $N$ be the total amount of discs and $B$ the amount of blue discs. There are $N^2-N$ ways to choose two discs, and $B^2-B$ ways to choose two blue discs. Therefore the numbers we're looking for will verify $\dfrac{B^2-B}{N^2-N}=\dfrac12\Rightarrow2\paren{B^2-B}=N^2-N$. It turns out that this is a very well known problem (diophantine pairs) and the solution can be found in OEIS (namely, it's the sequence A011900). The formula is a simple recurrence:

\begin{equation*}
a_n=\left\{\begin{array}{ll}n=0:&1;\\n=1:&3;\\\mathrm{otherwise:}&6a_{n-1}-a_{n-2}-2.\end{array}\right.
\end{equation*}
The result takes about $8\mu$s to be calculated, making this one of the few problems where the solution has $12$ digits yet it can be calculated by hand without needing an infuriating amount of patience. Also, the recurrence grows so fast that it really isn't worth the complete recurrence analysis, since the usage of double numbers to determine the limit is slow enough to eat the time gained by binary exponentiation. Go figure.

The first time I solved this, I used a different recurrence, which I found by inspection. It works just as well:
\begin{equation*}
\begin{array}{cc}
a_0=15;&a_n=3a_{n-1}+2b_{n-1}-2;\\
b_0=21;&b_n=4a_{n-1}+2b_{n-1}-3.
\end{array}
\end{equation*}

\section{Optimum polynomial}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 37076114526. \textit{Solved: Thu, 13 Aug 2015, 16:41}.

\textbf{Math knowledge used}: Lagrange interpolation.

\textbf{Programming techniques used}: none.

I can't believe that I spent so much time debugging this. For once, it's a bit of Java's fault, in that translating an assignment of the form $a+=b\cdot c$ into named functions was erroneously interpreted as $a=b.\mathrm{mul}\paren c$ instead of $a=a.\mathrm{add}\paren{b.\mathrm{mul}\paren c}$. Definitely my fault; but Java verbosity, for once, was a hindrance (math expressions have always been Java's Achilles heel...). Aside from that, the problem is incredibly simple: for $n=1\ldots10$, get the original polynomial values for $k=1\ldots n$, interpolate to get the $k-1$-th degree polynomial, and evaluate for $k=n+1$ (theoretically you should find the first value for which the interpolated polynomial does not equal the original one; but it's always $k=n+1$), add the result, which took me about $40$ms to compute.

This problem shouldn't be rated so high. Not even close.

\section{Triangle containment}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 228. \textit{Solved: Thu, 13 Aug 2015, 17:14}.

\textbf{Math knowledge used}: algebraic geometry.

\textbf{Programming techniques used}: none.

The issue here is: how to determine when does a triangle include the origin? It's quite easy. Given any two points, $p=\paren{p_x,p_y}$ and $q=\paren{q_x,q_y}$, we can extend the segment that joins these two points into a line whose equation is
\begin{equation*}
\paren{p_y-q_y}x+\paren{q_x-p_x}y+\paren{q_yp_x-q_xp_y}=0.
\end{equation*}
It's easy to see that this line includes $p$ and $q$ so it's the line we're looking for. Now, if we evaluate points at one side of the line we will always get positive numbers, and at the other side we will always get negative numbers. This is all we need to calculate the result, because we can do this:
\begin{itemize}
\item For each triangle, generate the three segment-extending lines.
\item Generate the triangle centroid as well, which will always be inside the triangle.
\item The origin is inside the triangle if and only if it's at the same side of all the three lines than the centroid.
\item Therefore we just evaluate the lines in both the center and the origin, and we increase the counter if the evaluation yields the same sign.
\end{itemize}
$15\%$ sounds about right.

\section{Special subset sums: optimum}
\textbf{Difficulty rating}: 45\%.

\textbf{Solution}: 20313839404245. \textit{Solved: Thu, 13 Aug 2015, 17:19}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Is this cheating? I don't know if it is. The fact is, the supposed ``algorithm that doesn't work'' given by the problem \textit{does} work for the case asked, even if it doesn't work for the general case.

So, the center element is $20$. We start with $20$, and then we add $20$ to each of $\llave{11,18,19,20,22,25}$. And yes, that's the result. Sure, it can be done properly, but this is kind of a trick question and it can be answered as such, right?

\section{Pandigital Fibonacci ends}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 329468. \textit{Solved: Thu, 13 Aug 2015, 20:13}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I don't think there is a reliable way of doing this with algorithmic magic, considering that the condition is difficult to translate to modular arithmetic and such. So this is about calculating a ``Fibonacci summary'' with the first and last digits, and updating both sets simply by doing $f_n=f_{n-1}+f_{n-2}$ where the addition operation is special.

The last digits are obvious to calculate: just compute modulo $10^9$ at each step. The first digits are more tricky, and I can see two ways of doing it. The first, which I used, is storing a big amount of digits (we can use up to $18$) and an offset, so that at each step we need to ensure that the offsets are ``leveled'', meaning that if one number has a lesser offset, then the number has to be divided to verify that the offsets are equal and the sum actually makes sense. The other way uses the formula $F_n\approx\dfrac{\varphi^n}{\sqrt5}$ so that, at each step, we can calculate $\log_{10}F_n$ just by adding $\log_{10}\varphi$ to the previous value, then we subtract $1$ if necessary so that the value is less than $9$, we exponentiate, and get the nearest integer. This procedure is definitely slower, but I expect it to be marginally more precise for extremely high values of $n$, which aren't necessary anyway.

\section{Special subset sums: testing}
\textbf{Difficulty rating}: 45\%.

\textbf{Solution}: 73702. \textit{Solved: Thu, 13 Aug 2015, 20:41}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I did this with a kind of brute force approach. It works, but as the next problem shows, it's probably not optimal. I relied on java Sets (namely, NavigableSets with a dash of IntObjMaps) to perform the comparisons.

The algorithm itself is not super complicated; for each set of numbers of length $N$, there are $2^N$ combinations of sums (although the first and last one are trivial), so generate all of them (I used some bit set black magic, not too difficult to understand, to do this), and check whether the conditions apply by filling a map of ordered sets where the key is the amount of addends and the value is the set of currently generated sums.

Out of the $100$ sets, there are $28$ that verify the condition. The algorithm runs in about one sixth of a second, which is kind of high. This is to be expected because it's brute force.

\section{Special subset sums: meta-testing}
\textbf{Difficulty rating}: 50\%.

\textbf{Solution}: 21384. \textit{Solved: Thu, 13 Aug 2015, 20:46}.

\textbf{Math knowledge used}: combinatorial numbers.

\textbf{Programming techniques used}: combination generation without repetition.

So, this is where Project Euler starts getting really hard. This problem has the property of being much more purely mathematical than ``operational'', in the sense that there is no way brute force could conceivably help you and you really need to analyse the problem.

What I did was the following: for each $n\in\corch{1,6}$, generate all the possible ordered rearrangements of the set $\corch{1,2n}$ into two arrays of size $n$, and if the arrays are not strictly ordered, in the sense that for index $i$ the first array has a bigger value than the second, but for other index $j$ it's the other way around, increase a counter, meaning that, if we started from an ordered array of size $2n$, we would need to check the sums for these pairs of indices. So, for each $n$ we end up with a counter $f\paren n$, but since there are of course $\displaystyle\binom{12}{2n}$ ways of choose $2n$ numbers from a set of $12$, the end result we need to calculate is this:
\begin{equation*}
\sum_{n=1}^6\binom{12}{2n}f\paren n.
\end{equation*}

This is a reasonably basic approach and it takes less than $4$ms in my machine. However, in the problem thread there are all kinds of wacky super-fast ways to calculate the result, including a lot of combinatorial arcane magic and some unexpected guests like the Catalan numbers. In particular, someone posted (without comment) some code implying that $f\paren n=\displaystyle\binom{2n-1}{n+1}$, which surely sounds kind of right, but it would be nice to prove it (I guess I could do it with a bit of time? I'm very sleepy right now). This reduces the problem to the calculation of a handful of combinatorial numbers (it also implies that $f\paren 1=0$, which again, sounds about right).

From now on, difficult problems appear without warning. This is what we came here for.

\section{Minimal network}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 259679. \textit{Solved: Thu, 13 Aug 2015, 23:22}.

\textbf{Math knowledge used}: graph theory, Kruskal's algorithm.

\textbf{Programming techniques used}: none.

Much easier than the previous one. Especially since it's an uber-standard problem for a first year Maths graduate. While it doesn't say it directly, the problem consists on calculating a minimal expansion tree. This can be done with a greedy algorithm called Kruskal's algorithm, as every discrete math student knows. I'm very surprised by that $35\%$ rating; I guess that at the time most of Project Euler participants came from CS backgrounds? But even then, they should know about Kruskal's algorithm. The only thing remotely difficult about this problem is how to determine that two vertices of a partial graph are connected, and ``remotely difficult'' still means ``almost trivially easy'' here.

\section{Diophantine reciprocals I}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 180180. \textit{Solved: Thu, 13 Aug 2015, 23:37}.

\textbf{Math knowledge used}: amount of divisors function.

\textbf{Programming techniques used}: prime power combination generation, lazily evaluated infinite lists, switched queues.

This problem allows a very reasonably simple analysis. The example allows us to observe that $n<x\leq2n$, and indeed it's easy to show that both $x$ and $y$ need to be greater than $n$, and that the highest value of $\mathrm{min}\llave{x,y}$ must be $2n$. This suggests to redefine $x=n+a$ where $a\in\corch{1,n}$, which gets us to:
\begin{equation*}
\dfrac1{n+a}+\dfrac1y=\dfrac1n\Rightarrow\dfrac{y+n+a}{y\paren{n+a}}=\dfrac1n\Rightarrow\paren{n+a}y=n\paren{y+n+a}.
\end{equation*}
From here we can clear $a$:
\begin{equation*}
\paren{n+a}y=n\paren{y+n+a}\Rightarrow ay=n^2+na\Rightarrow a=\dfrac{n^2}{y-n}.
\end{equation*}
So the possible values for $a$ are the divisors of $n^2$. However, this counts all solutions twice, since it includes the fraction sum in both directions. So if $n^2$ has $N$ divisors (which is always an odd number since, blatantly, $n^2$ is a perfect square), then the amount of distinct possible fractions is $\dfrac{N+1}2$.

We can start from this analysis and quickly get to a solution that works both for this problem and $110$ (which has the same problem definition, but a different input value). We need to generate all the possible prime power combination, and for each of them, we need to generate a representative, referring to the smallest number that has exactly that distribution of prime powers (i.e. for the set of prime powers $\corch{3,1,1}$ it would be $2^33^15^1$). Also we only need to generate prime powers in descending order, so $\corch{2,3,1}$ is not valid because we would use just $\corch{3,2,1}$. It's easy to uniquely generate all the powers as a lazily evaluated list if at each step we take the head, check it (finishing if the condition is met), and we create the children by either incrementing the last power value (unless it would result in an invalid number) or adding a new power. That is, for $\corch{3,2,1}$ the children would be $\corch{3,2,2}$ and $\corch{3,2,1,1}$, whereas for $\corch{4,4}$ the only child is $\corch{4,4,1}$.

The description looks longer than what is actually done. The code is quite simple, actually.

\section{Darts}
\textbf{Difficulty rating}: 45\%.

\textbf{Solution}: 38182. \textit{Solved: Thu, 13 Aug 2015, 23:58}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

For somethinig rated at $45\%$, this is underwhelmingly easy. I admit that the first time I confronted this problem I thought it could be one of the difficult ones. Then I read carefully the description and I didn't find the difficulty anywhere. More or less like with $54$, it looks like there could be a deeper, more interesting problem there, but there isn't. Sure, it's a bit tricky to get it right, but honestly I had more problems with stupid bugs (like using a $<$ where I should have used a $\leq$) than with the problem itself.

My method consists of keeping maps with amount of possible cases for each amount. So the first thing I do is to create a ``single throw'' map where I have added all the single throws, $\llave{1,2,3}\times\corch{1,20}$ and $\llave{25,50}$. Then I combine this map with itself to create a ``double throw'' set: for each pair (score,$n$) in the single set, I increase (score,$n$) and (2$\times$score,$\dfrac{n\paren{n+1}}2$) in the ``double throw'' set; and for each (unordered) pair, ((score1,$n$), (score2,$m$)), I increase (score1$+$score2,$nm$). Finally I add a single combination for $0$. After this I use a similar combination method to get all the triples from the set of doubles and the ``double value'' throws. In the resulting set, I just need to add all the values from the list of keys that are strictly smaller than $100$.

\section{Diophantine reciprocals II}
\textbf{Difficulty rating}: 40\%.

\textbf{Solution}: 9350130049860600. \textit{Solved: Thu, 13 Aug 2015, 23:39}.

\textbf{Math knowledge used}: amount of divisors function.

\textbf{Programming techniques used}: prime power combination generation, lazily evaluated infinite lists, switched queues.

This is exactly the same problem as $108$, with a higher limit. The algorithm works just as well, naturally.

\section{Primes with runs}
\textbf{Difficulty rating}: 45\%.

\textbf{Solution}: 612407567715. \textit{Solved: Fri, 14 Aug 2015, 00:02}.

\textbf{Math knowledge used}: Miller-Rabin primality test.

\textbf{Programming techniques used}: combination (without repetition) generation, variations (with repetition) generation.

This is laborious, but ultimately simple. Given the total amount of digits $D$, we iterate over the digits $d\in\corch{0,9}$; for each $d$ we iterate over the each amount of digits $n\in\corch{1,D-1}$ in reverse order. For each amount of digits $n$ we generate all the possible numbers with $D$ digits, $n$ of which are equal to $d$. Then we use a primality test to check whether they are prime or not, and whenever we find a value of $n$ for which we have fount at least one prime, we accept that set of primes for the digit $d$ (with $M\paren{D,d}=n$, $N\paren{D,d}$ is the amount of primes found and $S\paren{D,d}$ is its sum).

Of course, the difficult part is the generation of the numbers. I did the following: use a variation iterator for $D-n$ different digits from $0$ to $9$; discard the variation if it contains the ``repeating'' digit or if it would in a multiple of $3$; then, once that filter has passed, use a combination iterator to locate these new digits in a $D$ digit number (returning immediately if the number starts with $0$ or doesn't end in $1$, $3$, $7$ or $9$). It's a bit complicated but very doable in less than $100$ lines of code, and the run time is less than one sixth of a second, which is less than double what it takes for $4$ digits; not bad.

This is the table of results for $D=10$:
\begin{table}[H]
\centering\begin{tabular}{|c|c|c|c|}
\hline
Digit, $d$&$M\paren{10,d}$&$N\paren{10,d}$&$S\paren{10,d}$\\\hline
$0$&$8$&$8$&$38000000042$\\\hline
$1$&$9$&$11$&$12882626601$\\\hline
$2$&$8$&$39$&$97447914665$\\\hline
$3$&$9$&$7$&$23234122821$\\\hline
$4$&$9$&$1$&$4444444447$\\\hline
$5$&$9$&$1$&$5555555557$\\\hline
$6$&$9$&$1$&$6666666661$\\\hline
$7$&$9$&$9$&$59950904793$\\\hline
$8$&$8$&$32$&$285769942206$\\\hline
$9$&$9$&$8$&$78455389922$\\\hline
\end{tabular}
\end{table}

I've also adapted my code to run with BigIntegers, and using the highest set of Miller-Rabin witnesses I found on wikipedia, I was able to get the same table for $D=24$ in less than $0.9$ seconds, which is a very nice mark.
\begin{table}[H]
\centering\begin{tabular}{|c|c|c|c|}
\hline
Digit, $d$&$M\paren{24,d}$&$N\paren{24,d}$&$S\paren{24,d}$\\\hline
$0$&$21$&$363$&$187410752573439271524566739$\\\hline
$1$&$23$&$10$&$1251011015112011122111112$\\\hline
$2$&$22$&$25$&$5759572152579555626170689$\\\hline
$3$&$23$&$10$&$3833333342335338388332360$\\\hline
$4$&$22$&$33$&$14678463706598666441772499$\\\hline
$5$&$22$&$31$&$17462251567895192217959211$\\\hline
$6$&$22$&$29$&$18832048026225966363303047$\\\hline
$7$&$23$&$13$&$10112411111106122611119181$\\\hline
$8$&$22$&$26$&$23108009099049133406097586$\\\hline
$9$&$23$&$19$&$18592549180951350989999981$\\\hline
\end{tabular}
\end{table}
Total: $301040401775292608691432405$.

\section{Bouncy numbers}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 1587000. \textit{Solved: Fri, 14 Aug 2015, 00:56}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I'm not super proud of this, but it's fast and frankly I'm not sure if there is a \textit{precise} method to determine whether we hit or not any bouncy digit limit in a range. So I used brute force. That's it, check any number starting from $n=101$ (no number from $1$ to $100$ can be bouncy) until the counter is such that the nonbouncy numbers are $1\%$ of the total. I guess that you could increase the counter in hundreds instead of ones, with a bit of additional logic. Whatever: this finishes is $24$ms.

\section{Non-bouncy numbers}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 51161058134250. \textit{Solved: Fri, 14 Aug 2015, 01:03}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Now we're talking This problem is a bit more interesting than the previous one even if it's just a standard dynamic programming problem with a small twist. We need to count the amount of increasing numbers (dynamic programming with digits from $1$ to $9$; at each step, the value for digit $d$ is the sum of values for digits from $1$ to $d$ from the previous step) and the amount of decreasing numbers (dynamic programming with digits from $0$ to $9$; at each step, the value for digit $d$ is the sum of values for digits from $d$ to $9$ from the previous step), minus the $9\times100$ digits with same digits at all position, which have been counted twice because they appear in both cases. Finishes in less than one third of a millisecond!

\section{Counting block combinations I}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 16475640049. \textit{Solved: Fri, 14 Aug 2015, 11:41}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Incredibly easy dynamic programming problem. The difficulty rating is fucked. I distinctly remember solving all problems from $114$ to $117$ in half an hour (that's half an hour for \textit{all of them}, not half an hour per problem) one Sunday night after travelling from Málaga to Madrid, back in the day. Saying that these problems are easy is an understatement.

Anyway: keep two arrays of length $N+1$, one for chains ending in a gray block and another one for chains ending in a red block. At each time you can do $G\corch i=G\corch{i-1}+R\corch{i-1}$, and $R\corch i=\sum_{j=0}^{i-3}G\corch j$. Iterate using these formulas, and return $G\corch N+R\corch N$. It takes about $80$ fucking \textit{microseconds}.

\section{Counting block combinations II}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 168. \textit{Solved: Fri, 14 Aug 2015, 11:48}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Slightly less brutally easy than the previous one, since the length is unknown, but basically it's the same. Iterate in exactly the same way than before (except using $M=50$ instead of $3$), return when $G\corch i+R\corch i$ exceeds the limit. It takes about one millisecond and a half to run, and I blame this excessive run time in the dynamic memory allocation.

\section{Red, green or blue tiles}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 20492570929. \textit{Solved: Fri, 14 Aug 2015, 12:02}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Another variation in the coloured tiles dynamic programming problem, arguably even easier than the previous one since only one dimensional arrays are needed. In fact these ones have a very easy closed analysis and I could probably have used matrix exponentiation. I'm pretty sure that it would take more time than the current code, because the length $N=50$ is so small.

Anyway: you need a dynamic programming ``instance'' (i.e. a different array) for each of the colours. For each one of them, iterate using the formula $A\corch i=A\corch{i-1}+A\corch{i-L}$ where $L$ is the length of the color bar. Then return $A\corch N-1$ (we need to subtract the case with all gray tiles). Repeat for $L=2$, $L=3$ and $L=4$, add the results. It takes less than $20$ microseconds!

Also, yes, the case for $L=2$ is just Fibonacci numbers.

\section{Red, green and blue tiles}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 100808458960497. \textit{Solved: Fri, 14 Aug 2015, 12:10}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Like in the previous problem, a single array is needed. You can do $A\corch i=\sum_{j=1}^4A\corch{i-j}$, or compress the formula a little using a kind of telescopic reasoning, getting the slightly simpler $A\corch i=2A\corch{i-1}-A\corch{i-5}$. Runs in less than \textit{$9$ microseconds}.

\section{Pandigital prime sets}
\textbf{Difficulty rating}: 45\%.

\textbf{Solution}: 44680. \textit{Solved: Fri, 14 Aug 2015, 12:39}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: array partition generation, permutation generation.

Not that much of a real difficulty spike, but at least a real problem after the last four, which were laughably easy.

In order to solve this one, first I generated all the possible partitions of an array of nine length which could conceivably generate a set of primes (there are $24$). Generating these partitions is a bit tricky, so I wrote a partition generator class that could be useful in the future. Then I iterated over all the $9!$ possible permutations of the digits of $1$ to $9$, and for each combination of permutation and partition, I checked whether the combination generates an ordered set of primes (the ordered requirement ensures that no duplication happens; sets with two primes with the same length will be generated twice under this scheme). This takes a bit less than $3$ seconds, which is a lot compared with most problems so far (this is like the third or fourth problem that I didn't solve in less than $1$ second). I can think of an opposite approach that starts from the partitions, and for each of them, tries to generates prime sets given the partition sizes. Prime generation up to $10^8$ is still necessary, so I still wouldn't be able to get below $1$ second with this method, though.

\section{Digit power sum}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 248155780267521. \textit{Solved: Fri, 14 Aug 2015, 13:48}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: switched queues.

Is it cheating to assume that the number fits in a long? By that, we can assume that the number will have $18$ digits or less, so the sum of digits is going to be less than $162$. We can have a queue per number from $2$ to $162$, iterating over its powers, and switching the queues with a NavigableMap of queues' heads, so that at each moment the head of the queue is the smallest number we need to check.

The thirtieth number is $63^8$ (multiples of $9$ abound, as expected; there is a slight improvement to be made by using just powers that are guaranteed to preserve modulo $9$, but the gain is expected to be tiny). The bases range from $7$ (since $a_3=7^4=2401$) to $68$ (since $a_{27}=68^7=6722988818432$), and the exponents range from $2$ (for $a_1=9^2=81$) to $8$ (for $a_{28}=46^8$, $a_{29}=54^8$ and $a_{30}=63^8$). We can also find four more elements from the succession that also fit in a long:
\begin{itemize}
\item $a_{31}=54^9=3904305912313344$.
\item $a_{32}=71^9=45848500718449031$.
\item $a_{33}=20^{13}=81920000000000000$ (lovely, isn't it?).
\item $a_{34}=81^9=150094635296999121$.
\end{itemize}
My program takes about $12$ms, which is nice.

\section{Square remainders}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 333082500. \textit{Solved: Fri, 14 Aug 2015, 14:27}.

\textbf{Math knowledge used}: Newton's binomial theorem, Faulhaber formulas.

\textbf{Programming techniques used}: none.

This can be computed in \textit{constant} time. Assuming that the result fits in a long. Which totally does.

With Newton's binomial theorem we can easily get the following formula:
\begin{equation*}
r=\corch{\paren{a-1}^n+\paren{a+1}^n}\equiv\paren{-1}^{n-1}na+\paren{-1}^n+na+1\text{ (mod }a^2\text{)}.
\end{equation*}
For even values of $n$, the result is always $2$. For odd values, it's $2na$ (but we need to apply further modding), and now we're talking. If $a$ is odd, we can take either $n=\dfrac{a-1}2$ or $n=a+\dfrac{a-1}2$: we can guarantee that at least one of them will be even, and for that one, we arrive at $r_{\max}=a\paren{a-1}$. On the other hand, if $a$ is even, there are two cases that arrive at the same $r_{\max}$: if $\dfrac a2$ is even, $n=\dfrac a2-1$ does the trick; if it's odd, we need $n=a-1$.In both cases, $r_{\max}=a\paren{a-2}$. This is good enough to start operating:
\begin{equation*}
\sum_{a=3}^{1000}r_{\max}=\sum_{a=3,a\text{ odd}}^{1000}a\paren{a-1}+\sum_{a=3,a\text{ even}}^{1000}a\paren{a-2}.
\end{equation*}
Then we do $a=2k+1$ for odd numbers and $a=2k+2$ for even numbers, leaving:
\begin{equation*}
\sum_{a=3}^{1000}r_{\max}=\sum_{k=1}^{499}2k\paren{2k+1}+\sum_{k=1}^{499}2k\paren{2k+2}=\sum_{k=1}^{499}8k^2+6k.
\end{equation*}
Then, we define $N=\dfrac{1000-2}2=499$, and with Faulhaber formulas and a bit of additional cleaning we get
\begin{equation*}
\sum_{a=3}^{1000}r_{\max}=\dfrac{16N^3+30N^2+11N}6.
\end{equation*}
This formula runs in constant time and gets the result in $10\mu$s.

\section{Disc game prize fund}
\textbf{Difficulty rating}: 35\%.

\textbf{Solution}: 2269. \textit{Solved: Sat, 15 Aug 2015, 02:32}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: permutation iterator.

At turn $n$, there is a probability $\dfrac1n$ of getting a blue disc, and $\dfrac{n-1}n$ of getting a red one. So, I use some black magic (based on permutation iteration. C++'s next\_perm, we don't thank you enough) to enumerate all the winning combinations (for example, for $N=4$ turns the winning combinations would be $0111$, $1011$, $1101$, $1110$ and $1111$). For each one of them I calculate the numerator as a product of all the $n-1$ for the indices equal to $0$ in the combination, and then the denominator would be $\paren{N+1}!$. Dividing this denominator by the sum of all numerators and taking the floor returns the result. Less than $0.05$s, which is still kind of a lot, but then again I'm using permutation black magic.

\section{Efficient exponentiation}
\textbf{Difficulty rating}: 40\%.

\textbf{Solution}: 1582. \textit{Solved: Sat, 15 Aug 2015, 02:44}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: breadth-first search.

Yes, after writing the algorithm I realised that it was actually a multiple, condensed breadth-first search. With a lot of implicit memoisation. It sounds like I'm throwing random polysyllabic words, but I promise that it makes sense.

So, the problem looks like a standard partition problem, but it's more complicated (and that $40\%$ has reasons to be there). The important part is that dynamic programming won't work. Unless you generate \textit{all the possible ways} to generate each number. Which is not dynamic programming, but rather, brute force. A more elegant approach is to use a breadth-based search where you try to look for all the cases that can be generated at each depth level. And you store full ``paths'', meaning that if you are able to find $4$ with 2 steps, you need to store the full set of $\llave{1,2,4}$, because you will need to try all the combinations during the next level (actually you only need to combine $4$ with the other three? This would save some time, but it would require a more finely tuned structure). So far it seems kind of doable. However, if a number $x$'s optimum result is for depth $N$, then we need to make sure that \textit{every way of generating $x$ with $N$ multiplications is stored for the next level search}. Yes, this is necessary, otherwise you'll miss some cases and will get a wrong 1584 instead of the correct 1582. This took me off guard, because initially I was storing just the first path.

Anyway. Non optimized, yet it takes eighty-something milliseconds. Good, even if there is a bit of room for improvement.

By the way, the highest depth needed is $191$, with a depth of $11$. The generating set is $\llave{1,2,3,5,7,14,19,38,57,95,190}$. This is the only number with depth $11$, all the other can be obtained with $10$ or less.

\section{Prime square remainders}
\textbf{Difficulty rating}: 30\%.

\textbf{Solution}: 21035. \textit{Solved: Sat, 15 Aug 2015, 03:04}.

\textbf{Math knowledge used}: Newton's binomial theorem, Erathostenes sieve.

\textbf{Programming techniques used}: none.

This can be tricky to get right because of two reasons: 1) indices are, infuriatingly, starting from $0$ and not from $1$ (this makes sense mathematically, but fucks with calculations a bit), 2) we need to make sure that only odd indices are valid.

We determined in problem $120$ (using Newton's binomial theorem, which is otherwise not used at all in this problem, but it's necessary for the formula so I have included it) that $r=2$ if $n$ is even, and $r\equiv2na$ (mod $a^2$) if $n$ is odd. With this in mind, I did the following: first I generated an array of primes (I need the connection between primes and its index here!). Since Java arrays are $0$ based, \textbf{as they obviously and rightfully should be}\footnote{Have I mentioned today how \textit{much} do I hate Python?}, if the index of a prime $p$ in the array is $i$, the actual value of $n$ is $i+1$. Therefore I need to consider only \text{even} values of $i$. I also can start the search from the first prime that exceeds $10000$ (which can be found in the array with a binary search), and after that it's just a matter of iterating onwards. The prime limit I used was $1000000$, and the prime is actually $237733$, found in about $16$ ms.

\section{Ordered radicals}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 21417. \textit{Solved: Sat, 15 Aug 2015, 03:16}.

\textbf{Math knowledge used}: none

\textbf{Programming techniques used}: ``first prime'' Erathostenes sieve, memoisation.

There are two ways to solve this. Either you generate all the possible radicals (which means every squarefree number), and for each of them you generate all the numbers below the limit that have that radical, or you just generate all the radicals below the limit and sort them. The first alternative is better when the limit is very high, but it's not the case, so I opted for the second, which takes a bit less than $50$ms so all is good. For radical generation I can use a ``first prime'' sieve. If a number $n$ is prime, then the radical is $n$; if it has a prime factor $p$, then we can get $q=\mathrm{rad}\paren{n/p}$; if $q$ is a multiple of $p$, then $\mathrm{rad}\paren n=q$. Otherwise, it's $pq$.

By the way, the result is $3\cdot11^2\cdot59$.

\section{Palindromic sums}
\textbf{Difficulty rating}: 25\%.

\textbf{Solution}: 2906969179. \textit{Solved: Sat, 15 Aug 2015, 03:20}.

\textbf{Math knowledge used}: none

\textbf{Programming techniques used}: none.

I used an array with all the sums of squares (that is, element in position $n$ holds $\displaystyle\sum_{k=0}^nk^2$). I only need to check values up to $L'=\ceil{\sqrt{L/2}}$ since a sum needs to contain at least $2$ elements, and therefore the maximum possible is $L'^2+\paren{L'-1}^2$. After filling the array, I get all the possible differences from two values of this array whose indices differ in $2$ or more, and by doing this I'm iterating over all the possible differences. For all those values, I store the palindromes into a set, which I sum in the end (a set is needed because some values, namely $554455$ and $9343439$, are found twice). The result of the problem is the sum of all elements in the set. Finishes in $75$ milliseconds.

\section{Cuboid layers}
\textbf{Difficulty rating}: 55\%.

\textbf{Solution}: 18522. \textit{Solved: Sat, 15 Aug 2015, 04:04}.

\textbf{Math knowledge used}: none

\textbf{Programming techniques used}: none.

I have a low-key dislike for this problem. Sure, it's one of these ``barrier-breaking'' ones whose difficulty is higher than any problem before, but I feel like the reason for it is not that the problem is interesting, but rather, that the interesting and elegant approaches don't work.

First, the basics: if I have a cuboid of size $x\times y\times z$, the $n$-th layer has exactly this many cubes:
\begin{equation*}
f_n\paren{x,y,z}=2\paren{xy+xz+yz}+4\paren{x+y+z+n-2}\paren{n-1}.
\end{equation*}
This is all fine until you notice that the second term has a quadratic term in $n$, meaning that $f_n\paren{x,y,z}=L$ (for whichever $L$) isn't just a diophantic equation: it's a \textit{quadratic} diophantic equation. With $4$ variables. This means that it's quite hard to solve, even with the help of the mighty Alpertron. It can be done, though, and this suggests a method: iterate over even $L$ values, count the amount of solutions, return when it's higher than the limit. However, this method is both difficult to get right and surprisingly slow. A much better solution is to just use brute force, counting all the layers up to certain arbitrary limit (I used $30000$). That's it: iterate over triples $\paren{x,y,z}$, adding the condition $x\leq y\leq z$, and for each one, iterate $n$ until $f_n\paren{x,y,z}$ exceeds the limit, increasing a counter for each resulting amount of blocks. Then, when you have finished iterating, check the counters and return the first one that equals the given limit. This gets the result in about $50$ms.

\section{abc-hits}
\textbf{Difficulty rating}: 50\%.

\textbf{Solution}: 18407904. \textit{Solved: Sat, 15 Aug 2015, 12:17}.

\textbf{Math knowledge used}: none

\textbf{Programming techniques used}: ``first prime'' Erathostenes sieve, memoisation.

A well-deserved $50\%$, for such a relatively early problem. The radical of a number is calculated in the same way than in problem $12$. We are looking for highly powerful (as in, contains powers) values of $c$ (if $c$ is squarefree, then $\mathrm{rad}\paren c=c$, therefore $\mathrm{rad}\paren{abc}\geq c$). For each $c$, we can look for values of $a$ that are coprime with $c$ and that verify the conditions. So, we iterate from $1$ to $\floor{\dfrac c2}$ (since $a<b$) and check every case. Very slow (almost $1.5$ seconds), but does the job. It's helpful to note that we can compute $\mathrm{rad}\paren{abc}$ quickly since the coprimality implies $\mathrm{rad}\paren{abc}=\mathrm{rad}\paren a\mathrm{rad}\paren b\mathrm{rad}\paren c$, thus the memoisation.

Also, take care about overflow. Either use longs, or compare $\mathrm{rad}\paren a\mathrm{rad}\paren b$ against $\frac{\mathrm{rad}\paren c}c$ instead of doing the full calculation.

\section{Hexagonal tile differences}
\textbf{Difficulty rating}: 55\%.

\textbf{Solution}: 14516824220. \textit{Solved: Sat, 15 Aug 2015, 12:25}.

\textbf{Math knowledge used}: Erathostenes sieve, Faulhaber formulas.

\textbf{Programming techniques used}: none.

I get why this problem has a $55\%$, but I still don't think it's quite right. There is a lot of preanalysis to be made, though.

First: cases $1$ and $2$ are special, and should be counted initially. So is $7$, but this one doesn't verify the condition, so no need to count it. Now, we work in rings (this is not a particularly difficult epiphany to get, but it's an essential one); and for each ring $r$, it's easy to see that only the first and last elements might have $3$ prime differences: let $n$ be an ``internal'' element; both $n-1$ and $n+1$ are present, and there are also two contiguous elements from both the previous and the next rings: $m$ and $m+1$ from one side, $p$ and $p+1$ from other. Since only one at most of $\llave{m,m+1}$ and only one at most of $\llave{p,p+1}$ may have a prime difference with $n$, the maximum difference is $2$. However, for the first and last of the ring, the difference between them is $6r+5$; if it's prime, the first and last elements in the ring may verify the condition. They have to be checked separately.
\begin{itemize}
\item For the first one, the differences are: $6r+6$; $12r+17$; $6r+5$; $6r$; $1$; and $6r+7$. Out of these, only $6r+5$, $6r+7$ and $12r+17$ might be prime. The number itself is $3r\paren{r+1}+2=3r^2+3r+2$.
\item For the last one, the differences are: $6r+12$; $6r+11$; $1$; $6r+6$; $12r+5$; and $6r+5$. The only possible primes are $6r+5$, $6r+11$ and $12r+5$. The number itself is $3\paren{r+1}\paren{r+2}+1=3r^2+9r+7$.
\end{itemize}
Note that the indices of the number can be calculated using a careful but basic approach with triangular numbers (or Faulhaber formulas if you want to be posh).

To check for primality you could use Miller-Rabin, but the numbers don't get very high, so you can use a sieve with some low value. I used $10^6$ without thinking much, and it seems that the highest number checked is $834761$. The runtime is very low thanks to the sieve; about $16$ms.

\section{Repunit divisibility}
\textbf{Difficulty rating}: 45\%.

\textbf{Solution}: 1000023. \textit{Solved: Sat, 15 Aug 2015, 12:47}.

\textbf{Math knowledge used}: infinite decimal period distributions.

\textbf{Programming techniques used}: none.

The period of a number $n$ is always smaller than $n$; the period is always a multiple of the first divisible repunit, and both number are equal, at the very least, if $n$ is not a multiple of $3$. I expected this to be a prime, which caught me off guard, but it turns out that you can't skip composite numbers because the answer is in fact composite.

Start from $10^6$ (otherwise, your algorithm will be $O\paren{n^2}$ instead of $O\paren n$. Not good when $n=10^6$), and for each one, keep iterating from $m=1$ to $m=10(m\%n)+1$ until some $m\%n$ equals $0$. Starting from $10^6$ and ignoring even numbers and multiples of $5$, only $10$ numbers need to be checked. There are a lot of divisions, though, so the run time is a bit more than $10$ms.



\end{document}
