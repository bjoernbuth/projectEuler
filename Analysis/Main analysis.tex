\documentclass[a4paper,12pt]{article}

\usepackage[latin1]{inputenc}
\usepackage[spanish,es-tabla]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage{units}
\usepackage{color}
\usepackage{float}
\usepackage{longtable}
\usepackage{mathrsfs}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{relsize}
%\usepackage{mathabx}
\usepackage{ulem}

\bibliographystyle{alpha}

%\doublespacing
\clubpenalty=10000
\widowpenalty=10000

\DeclareMathOperator{\arccot}{arc\ cot}
\DeclareMathOperator{\arcsec}{arc\ sec}
\DeclareMathOperator{\arccsc}{arc\ csc}
\DeclareMathOperator{\sech}{sech}
\DeclareMathOperator{\csch}{csch}
\DeclareMathOperator{\argsenh}{arg\ senh}
\DeclareMathOperator{\argcosh}{arg\ cosh}
\DeclareMathOperator{\argtgh}{arg\ tgh}
\DeclareMathOperator{\argcoth}{arg\ coth}
\DeclareMathOperator{\argsech}{arg\ sech}
\DeclareMathOperator{\argcsch}{arg\ csch}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\mcd}{mcd}
\DeclareMathOperator{\modX}{m\acute od}
\DeclareMathOperator{\Cov}{Cov}

\pgfplotsset{compat=1.12}

\begin{document}

\newlength{\origpar}
\setlength{\origpar}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\parindent}{\origpar}

\renewcommand {\baselinestretch} {1.0}
\renewcommand*{\arraystretch}{1.5}

\newcommand{\paren}[1]{\ensuremath{\left(#1\right)}}
\newcommand{\corch}[1]{\ensuremath{\left[#1\right]}}
\newcommand{\llave}[1]{\ensuremath{\left\{#1\right\}}}
\newcommand{\angparen}[1]{\ensuremath{\left<#1\right>}}
\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\vecnorm}[1]{\ensuremath{\left|\left|#1\right|\right|}}
\newcommand{\pdiff}[2]{\ensuremath{\dfrac{\partial#1}{\partial#2}}}
\newcommand{\tlap}[1]{\ensuremath{\mathscr L\llave{#1}}}
\newcommand{\itlap}[1]{\ensuremath{\mathscr L^{-1}\llave{#1}}}
\newcommand{\Section}[1]{\renewcommand{\thesection}{#1}\section}
\newcommand{\floor}[1]{\ensuremath{\left\lfloor#1\right\rfloor}}
\newcommand{\ceil}[1]{\ensuremath{\left\lceil#1\right\rceil}}

\newcommand{\zm}[1]{\ensuremath{\mathbb Z/#1\mathbb Z}}

\definecolor{grey}{rgb}{0.50,0.50,0.50}
\definecolor{moradoesfruta}{rgb}{1,0,1}
\definecolor{orangeisthenewmorado}{rgb}{1,0.5,0}

\newcommand{\inRed}[1]{\textcolor{red}{#1}}
\newcommand{\inBlue}[1]{\textcolor{blue}{#1}}
\newcommand{\inGreen}[1]{\textcolor{green}{#1}}
\newcommand{\inPurple}[1]{\textcolor{moradoesfruta}{#1}}
\newcommand{\inOrange}[1]{\textcolor{orangeisthenewmorado}{#1}}

\newcommand{\SectionR}[1]{\renewcommand{\thesection}{\inRed{#1}}\section}
\newcommand{\SectionG}[1]{\renewcommand{\thesection}{\inGreen{#1}}\section}
\newcommand{\SectionO}[1]{\renewcommand{\thesection}{\inOrange{#1}}\section}

\newcommand{\matlab}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{black}{#1}}}\end{singlespace}}
\newcommand{\maxima}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{blue}{#1}}}\end{singlespace}}
\newcommand{\maximaoutput}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{grey}{#1}}}\end{singlespace}}
\newcommand{\scilab}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{black}{#1}}}\end{singlespace}}

% Magia negra de Latex a continuación (copiada de http://tex.stackexchange.com/questions/44235/is-there-a-way-to-do-an-upside-down-widehat).
\makeatletter
\DeclareRobustCommand\widecheck[1]{{\mathpalette\@widecheck{#1}}}
\def\@widecheck#1#2{%
    \setbox\z@\hbox{\m@th$#1#2$}%
    \setbox\tw@\hbox{\m@th$#1%
       \widehat{%
          \vrule\@width\z@\@height\ht\z@
          \vrule\@height\z@\@width\wd\z@}$}%
    \dp\tw@-\ht\z@
    \@tempdima\ht\z@ \advance\@tempdima2\ht\tw@ \divide\@tempdima\thr@@
    \setbox\tw@\hbox{%
       \raise\@tempdima\hbox{\scalebox{1}[-1]{\lower\@tempdima\box
\tw@}}}%
    {\ooalign{\box\tw@ \cr \box\z@}}}
\makeatother
% Fin de la magia negra.

\setcounter{secnumdepth}{3}
\section{Multiples of 3 and 5}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 233168. \textit{Solved: Sat, 8 Aug 2015, 08:09}.

\textbf{Math knowledge used}: triangular numbers.

\textbf{Programming techniques used}: none.

It's very simple using inclusion-exclusion. We count how many multiples of $3$, $5$ and $15$ are there, then we use triangular numbers to determine each sum, then we return $\mathrm{sum}\paren3+\mathrm{sum}\paren5-\mathrm{sum}\paren{15}$.

\section{Even Fibonacci numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4613732. \textit{Solved: Sat, 8 Aug 2015, 08:23}.

\textbf{Math knowledge used}: recurrence equation theory.

\textbf{Programming techniques used}: none.

You can bruteforce this very easily. Or you can use recurrence equations! Which is of course my preferred method since it's more mathematical and, much more importantly, more scalable.

So, fibonacci numbers follow this formula:
\begin{equation*}
f\paren n=\dfrac{\varphi^n-\paren{1-\varphi}^n}{\sqrt5}.
\end{equation*}

And even fibonacci numbers are precisely those for which $n=\dot3$. That is, the numbers we are looking for follow this other formula:
\begin{equation*}
f_{\mathrm even}\paren n=\dfrac{\varphi^{3n}-\paren{1-\varphi}^{3n}}{\sqrt5}.
\end{equation*}

From this, considering that $\paren{1-\varphi}^{3n}$ tends to $0$ very rapidly, and calling $L=4e6$ the imposed limit, we can get a suitable formula for the largest $n$ we need:
\begin{equation*}
N=\floor{\dfrac{\log L}{3\log\varphi}}.
\end{equation*}

Finally, since we need the sum, we use a basic summation formula (again, considering that the $\paren{1-\varphi}^{3n}$ terms tend quickly to zero):
\begin{equation*}
\sum_{i=0}^n\dfrac{\varphi^{3n}-\paren{1-\varphi}^{3n}}{\sqrt5}\approx\sum_{i=0}^n\dfrac{\varphi^{3n}}{\sqrt5}=\dfrac{\varphi^{3n+3}-\varphi^3}{\paren{\varphi^3-1}\sqrt5}.
\end{equation*}
Rounding this value into the nearest integer we get the solution.

\section{Largest prime factor}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 6857. \textit{Solved: Sat, 8 Aug 2015, 08:33}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

Very simple, just enumerate all the primes up to $\sqrt L$ (with $L$ being the limit) and then divide until either we hit $1$ (meaning that the last prime we divided by is the result) or we run out of primes (meaning that the remaining number is the last prime we're looking for).

There are many methods that can be used to iterate over the primes, but the Erathostenes sieve is good enough. Saying that it will be used profusely is a big, big understatement.

\section{Largest palindrome product}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 906609. \textit{Solved: Sat, 8 Aug 2015, 08:39}.

\textbf{Math knowledge used}: modular arithmetic.

\textbf{Programming techniques used}: none.

The ``modular arithmetic'' I'm referring to is just the fact that I know that all palindrome numbers with an even amount of digits are multiples of $11$. So, the method to found this answer is as simple as iterating downwards over a pair of factors, but this bit of knowledge allows me to reduce the search space by 11, because one of the factors iterates over just multiples of $11$.

\section{Smallest multiple}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 232792560. \textit{Solved: Sat, 8 Aug 2015, 08:49}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I'm not sure if ``none'' qualifies as the list of special knowledge used. I just factored all the numbers and then calculated the least common multiple in a more or less intelligent way (i.e. I have the factors, so no need to use Euclid's algorithm). This is the first time I used my DivisorHolder class, which is used for a fuckton of problems all over the list.

\section{Sum square difference}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 25164150. \textit{Solved: Sat, 8 Aug 2015, 08:54}.

\textbf{Math knowledge used}: basic Faulhaber formulas.

\textbf{Programming techniques used}: none.

The sum of all natural numbers up to $n$ is $\dfrac{n\paren{n+1}}2$, and if we square this we get:
\begin{equation*}
f\paren n=\dfrac{n^4+2n^3+n^2}4.
\end{equation*}

On the other hand, the sum of the squares of all the natural numbers up to $n$ is
\begin{equation*}
g\paren n=\dfrac{2n^3+3n^2+n}6.
\end{equation*}

Subtracting both numbers we get the formula we need:
\begin{equation*}
f\paren n-g\paren n=\dfrac{3n^4+2n^3-3n^2-2n}{12}.
\end{equation*}

Plugging in $n=100$ we get the result. By the way, it can be easily proven that despite the denominator this number is always an integer.

\section{10001st prime}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 104743. \textit{Solved: Sat, 8 Aug 2015, 09:02}.

\textbf{Math knowledge used}: Erathostenes sieve, $\pi\paren n$ counting function.

\textbf{Programming techniques used}: none.

Just use an Erathostenes sieve. As for the limit, we know that $\pi\paren x\approx\dfrac x{\log x}$, so if the limit is $L=10001$, then we can use $N=2L\log L$ (multiplying times $2$ is a safe addition. The formula I gave means that $x\approx\log x\cdot\pi\paren x$, but we have $\pi x$, and this formula doesn't say anything about $\log\pi\paren x\cdot\pi\paren x$). Then just move over the sieve until we have passed over $L$ primes.

\section{Largest product in a series}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 23514624000. \textit{Solved: Sat, 8 Aug 2015, 09:11}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

This is more algorithmic than mathematic, but still, it's not like it has much algoritmic depth. You can either iterate over the list, taking care about how the zeros break the chains, or just split the string into smaller strings of digits using the $0$ as separator, so that the remaining strings are safer to iterate. In any case the search algorithm is basically obvious (take the first $N$ digits as product, then at each step divide by the $\paren{i-N}$-th and multiply by the $i$-th. Take the maximum you found).

\section{Special Pythagorean triplet}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 31875000. \textit{Solved: Sat, 8 Aug 2015, 09:20}.

\textbf{Math knowledge used}: Pythagorean triples generation.

\textbf{Programming techniques used}: none.

So, this is the first problem that uses Pythagorean triple generation, another staple of Project Euler (not nearly as ubiquitous as prime generation, but still). This problem is very simple: if we can reliably generate all the primitives, then we will find some primitive so that $a+b+c=k$ and $N=1000$ is a multiple of $k$, $N/k=q\in\mathbb N$. In that case, we scale the triple to get $\paren{qa,qb,qc}$ so that $qa+qb+qc=1000$, and so the answer is $\paren{qa}\paren{qb}\paren{qc}=q^3abc$. By the way, the solution is the triple $\paren{15,8,17}$, which gets scaled into $\paren{375,200,425}$.

\section{Summation of primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 142913828922. \textit{Solved: Sat, 8 Aug 2015, 09:42}.

\textbf{Math knowledge used}: Prime summation function.

\textbf{Programming techniques used}: none.

This is an \textit{absolutely awesome} problem, disguised as a boring tutorial. Now, in certain way I could say the same about problem 2, right? But in that case, the interesting technique is very widely known and available to every first year maths student. In this case the magic is a little more obscure, although it's still very useful all over Project Euler.

So, the magic is that there is a recursive function that calculates the sum of primes in something like $O\paren{n^{2/3}}$ time, meaning that the result of this problem takes about $30$ milliseconds to get, AND that if I want to calculate the sum of all primes up to, say, $10^{12}$, it's perfectly doable. No need to generate all the primes explicitly. Yes, this \textit{will} be used (sparingly, but decisively) all over Project Euler.

Credits for this awesome function go to user \textbf{Lucy\_Hedgehog} of Project Euler. The algorithm itself is described in the comments of the problem, in what could very well be the highest rated comment of all the site.

\section{Largest product in a grid}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 70600674. \textit{Solved: Sat, 8 Aug 2015, 10:23}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Just a rehash of problem 8, more complicated because there are a lot more lines to take into account. This is purely algorithmic but it's more grit than anything. What I did was:
\begin{enumerate}[1.]
\item Parse the input into a 2D int array.
\item Generate all the horizontal, vertical and diagonal (in both directions) lines.
\item For each one of the generated lines, separate them into zero-less chunks, discarding the ones that are too short.
\item Get the maximum product of each of these chunks, using the very same function as in problem 8.
\item The maximum of all chunks' maxima is the result.
\end{enumerate}

\section{Highly divisible triangular number}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 76576500. \textit{Solved: Sat, 8 Aug 2015, 11:00}.

\textbf{Math knowledge used}: triangular numbers.

\textbf{Programming techniques used}: none.

Very easy. For each $N\geq2$, get the prime factorization of both $N-1$ and $N$, combine them, then remove a $2$. Count the amount of divisors of the resulting number, and if it's greater than the limit, return the number $\dfrac{N\paren{N-1}}2$. All of this can be reliably done with my DivisorHolder class that keeps the factorization using an IntIntMap.

By the way, the answer comes from $N=12376$, i.e. from $T\paren{12375}$. $12375=3^2\cdot5^3\cdot11$ and $12376=2^3\cdot7\cdot13\cdot17$, so the resulting triangular number is $2^2\cdot3^2\cdot5^3\cdot7\cdot11\cdot13\cdot17$, which has $3\cdot3\cdot4\cdot2\cdot2\cdot2\cdot2=576$ divisors.

\section{Large sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 5537376230. \textit{Solved: Sat, 8 Aug 2015, 11:30}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I wouldn't call the usage of BigInteger a ``programming technique''. In the end this problem isn't even algorithmic. On the good side, this is a good example of the advantage of Java Streams, since I can do all the additions without resorting to an explicit list of BigInteger; the original stream of lines returned by Files.lines can be used directly. Yay, I guess.

In most Project Euler problems, and that includes this one, the usage of BigInteger (or integers larger than 64 bits, for that matter) is not strictly unneeded. Still, there are many problems where they come in very handy.

\section{Longest Collatz sequence}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 837799. \textit{Solved: Sat, 8 Aug 2015, 11:54}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: memoization.

This can be done without memoization, but it's super slow. With memoization, it takes less than half a second, which is much more than anything before this problem but it's still short and sweet.

\section{Lattice paths}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 137846528820. \textit{Solved: Sat, 8 Aug 2015, 11:59}.

\textbf{Math knowledge used}: combinatorial numbers.

\textbf{Programming techniques used}: none.

Very simple. The amount of routes is just the amount of permutations between $20$ displacements to the right and $20$ displacements to the bottom. Therefore the result is $\displaystyle\binom{20+20}{20}$.

Of course, you can also try to manually enumerate all the possible paths. Good luck. This might be the first problem where, if you are \textit{completely} clueless, there's no way you are going to get the result.

\section{Power digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1366. \textit{Solved: Sat, 8 Aug 2015, 12:18}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: binary exponentiation.

This is one of the very few cases where I don't think you can solve this problem without resorting to a BigInteger or to a similar trick like a string of digits. It's not like it's much of a problem, though.

I'm counting binary exponentiation as a programming technique, although it's a very simple one (and arguably you could put into the ``mathematical knowledge'' bin). This will also be used very often all over Project Euler.

\section{Number letter counts}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 21124. \textit{Solved: Sat, 8 Aug 2015, 12:37}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I'm a bit torn about this problem. On one hand, the concept is kind of beautiful. I'm almost tempted to solve it in different languages like German or Finnish. On the other hand, coding it was repetitive and tedious.

The obvious way to solve this problem is generating all the strings and counting all the letters. Super-tedious. What I did was different: I enumerated all the words and then counted, for each one, in how many words appeared (all the cases are reasonably simple). Multiplying by the word's length, and adding the results, yields the solution.

\section{Number letter counts}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1074. \textit{Solved: Sat, 8 Aug 2015, 13:03}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: greedy algorithm.

Finally some actual algorithmics, even if very simple. A greedy algorithm that gets the best sum from both ``parents'' from above is good enough.

\section{Counting Sundays}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 171. \textit{Solved: Sat, 8 Aug 2015, 13:14}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

This is stupidly simple but I kept getting the wrong result because I used a monday as a starting point, but this is not what I need to use since I must count from 1901 onwards and the date I'm given is from 1900, not 1901.

The method itself: well, there are only 14 types of years. So I count how many of each type are there in the period from 1901 to 2000, then for each year type I count how many months start on a Sunday. Multiply and accumulate the sum. End.

\section{Factorial digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 648. \textit{Solved: Sat, 8 Aug 2015, 13:16}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Similar to problem 16, but even more simple because there is no binary exponentiation, just creating the factorial and adding the digits. Not much more to add, except that this is one of the cases where BigInteger or equivalent is really, actually needed.

\section{Amicable numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 31626. \textit{Solved: Sat, 8 Aug 2015, 13:40}.

\textbf{Math knowledge used}: divisor sum properties.

\textbf{Programming techniques used}: memoization.

The formula I've listed under ``divisor sum properties'' is the following: if a number's prime decomposition is
\begin{equation*}
N=\prod_{i=1}^mp_i^{e^i},
\end{equation*}
then the sum of its divisors is
\begin{equation*}
S\paren N=\prod_{i=1}^m\dfrac{p_i^{e^i+1}-1}{p_i-1}.
\end{equation*}
So the proper sum of divisors is $S\paren N-N$, and that's all the maths needed for this problem. So we keep two maps of $N\rightarrow S\paren N-N$, one with the abundant numbers ($S\paren N>2N$) and another one with the defective numbers ($S\paren N<2N$). No need to store perfect numbers. Then we iterate over the abundant numbers map (which is the smaller of the two), looking for entries where the key-value pair appears as value-key in the defective map. Of course, a single map can be used with all the numbers, but it will be slightly slower.

\section{Names scores}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 871198282. \textit{Solved: Sat, 8 Aug 2015, 14:05}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Yeah, I refuse to call a sort function a ``programming technique''. I don't like this problem, mostly because it's too streamlined and basically the description tells you exactly what to do. No room for finesse or for improvements. Just read the (single line) file, parse it into a list of names, sort it, then use the given algorithm to calculate the result.

\section{Non-abundant sums}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4179871. \textit{Solved: Sat, 8 Aug 2015, 14:20}.

\textbf{Math knowledge used}: divisor sum properties.

\textbf{Programming techniques used}: none.

Using the same divisor function as in problem 21, the algorithm is simple: generate the set all the abundant numbers up to the given limit using said numbers, then generate all the possible sums of two values of the set below the limit. Then iterate over all the numbers up to the limit and add them to a tally if they are not in the set of sums. There is a modicum of brute force in the sum generation process so this takes nearly half a second.

\section{Lexicographic permutations}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 2783915460. \textit{Solved: Sat, 8 Aug 2015, 14:36}.

\textbf{Math knowledge used}: factorial number system.

\textbf{Programming techniques used}: none.

I said that I didn't like 22, right? 24 is the opposite. It's very nice, and for such an early problem, it has room for a clever usage of maths that eschews brute force. I could have replaced the math knowledge about the factoradic system with programming technique about permutation enumeration, but that would require a million operations, while using factoradic requires ten, and probably faster ones.

In a nutshell: you can either enumerate a million partitions (slow) or just represent $10^6-1$ in factoradic (fast!). I obviously opted for the second way.

\section{1000-digit Fibonacci number}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4782. \textit{Solved: Sat, 8 Aug 2015, 14:41}.

\textbf{Math knowledge used}: recurrence equation theory.

\textbf{Programming techniques used}: none.

Just like in problem 2, we can use the formula
\begin{equation*}
F_n=\dfrac{\varphi^n-\paren{1-\varphi}^n}{\sqrt5}\approx\dfrac{\varphi^n}{\sqrt5}.
\end{equation*}
We need to calculate the first $n$ so that $F_n\geq10^{1000-1}$ (note that $10^{1000}$ has \textit{1001} digits, not 1000). Solving for $n$ we get:
\begin{equation*}
\dfrac{\varphi^n}{\sqrt5}\geq10^{999}\Rightarrow n\geq\dfrac{999\log10+\log\sqrt5}{\log\varphi}\Rightarrow n=\ceil{\dfrac{999\log10+\log\sqrt5}{\log\varphi}}.
\end{equation*}
Of course this calculation is super fast, on par with the first two problems in speed.

\section{Reciprocal cycles}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 983. \textit{Solved: Sat, 8 Aug 2015, 15:03}.

\textbf{Math knowledge used}: infinite decimal period distributions.

\textbf{Programming techniques used}: none.

The keys to this algorithm are two: the first one is that the period length of $1/n$ can only have as much as $n-1$ digits; the second one is that $n-1$ is only reached, in fact, if $n$ is prime. While it's not strictly true that the result \textit{needs} to be a prime, it's very likely, so I just iterated downwards over the primes, calculating the cycle length and stopping whenever the current value was smaller than the greatest length found. The result is found almost instantly (less than 1ms) because the result is close to the limit.

\section{Quadratic primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: -59231. \textit{Solved: Sat, 8 Aug 2015, 15:20}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

The only useful insight for this problem is that $b$ has to be a prime, otherwise of course we don't get any prime because for $n=0$ the polynomial doesn't yield a prime and we stop immediately. Also, once this is taken care of, we can start the iterations from $n=1$ instead of $n=0$ since of course we got a prime for $n=0$. This shaves some... nanoseconds? from the run time. Another nano-optimization is calculating the polynomial value by incrementing the previous value in $2n+a-1$, instead of calculating the complete value each time. Aside from all that swill, this is just iterating over $\corch{-L\ldots L}$ for $a$, and over the primes smaller than $L$ for $b$, and then calculating the polynomial values. By the way, the solution is reached for $a=-61$, $b=971$, for a total of $71$ primes.

\section{Number spiral diagonals}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 669171001. \textit{Solved: Sat, 8 Aug 2015, 15:34}.

\textbf{Math knowledge used}: basic Faulhaber formulas.

\textbf{Programming techniques used}: none.

Another hyper-fast one. Sure, you can iterate over the numbers and build the spiral manually or whatever, but why do that when each half diagonal follows a very clear formula? So, if the length we are looking for is $L=1001$, the half diagonals have a size of $N=\dfrac{L-1}2=500$. The formulas for the half diagonal numbers are very simple:
\begin{eqnarray*}
F_1\paren n&=&4n^2-2n+1;\\
F_2\paren n&=&4n^2+1;\\
F_3\paren n&=&4n^2+2n+1;\\
F_4\paren n&=&4n^2+4n+1.
\end{eqnarray*}
The sum of all these values is $S\paren n=16n^2+4n+4$, so the result of the problem is
\begin{equation*}
1+\sum_{n=1}^N\paren{16n^2+4n+4}=1+4N+4\sum_{n=1}^Nn+16\sum_{n=1}^Nn^2.
\end{equation*}
With the Faulhaber formulas for $k=1$ and $2$ we can summarize this result as
\begin{equation*}
1+\dfrac{32N^3+60N^2+52N}6.
\end{equation*}
Plugging $N=500$ yields the result.

Side note: I'm slightly triggered by the fact that the spiral moves in \sout{clockwise}negative direction.

\section{Distinct powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 9183. \textit{Solved: Sat, 8 Aug 2015, 15:46}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I overengineered this problem in order to make a generic algorithm that would work for bigger values. It was \textit{delightful}.

The obvious algorithm generates all the algorithm (using BigInteger, or logarithms, or whatever). Instead, what I did was counting the amount of powers of each type present in the algorithm, and for each of them, I counted the new exponents that each type could generate. In the given range there are $87$ normal numbers ($99$ new values each), $6$ square numbers ($50$ new values each), $2$ cubes ($50$ new values each), $2$ fourth powers ($41$ new values each), and a fifth and a sixth power ($51$ and $37$ new values respectively). So: $87\cdot99+6\cdot50+2\cdot50+2\cdot41+51+37=9183$.

\section{Digit fifth powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 443839. \textit{Solved: Sat, 8 Aug 2015, 16:13}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: combination generation (with repetition).

Ah, yes. Reusing pays. I have a generic combination generator which is \textit{very useful} since there are a lot of problems that require generating all the \textit{unordered} combinations of certain set of values. I started it long ago and it's currently refined into a very reasonable, fast and usable class. So, with that generator in my hands, I just need to generate all \textit{six} or less combinations of numbers between $0$ and $9$, and for each of them, verify whether the sum of fifth of powers matches the combination. Why six digits, precisely? Because for seven digits we can't get numbers, because the maximum valus is below the minimum: $7\cdot9^5<10^7$. For six digits it happens that $6\cdot9^5\geq10^6$, so they must be taken into account.

There are six such numbers: $4150$, $4151$, $93084$, $92727$, $54748$ and $194979$. See, I told you, six digits are needed.

\section{Coin sums}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 73682. \textit{Solved: Sat, 8 Aug 2015, 16:29}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Classic dynamic programming problem. Only two arrays need to be kept at each time: the previous one, $P$, which for each index $i$ contains the amount of ways to sum up to $i$ using all the previously visited coins, and the new one, $N$, associated to the new coin with value $c$, which we generate like this:
\begin{equation*}
N\corch i=\sum_{k=0}^{\floor{\frac ic}}P\corch{i-kc}.
\end{equation*}
The first array for $c=1$ is all ones, and then we iterate for each one of the remaining coins, $c\in\llave{2,5,10,20,50,100,200}$. The problem solution is the value for index $200$ in the last array.

\section{Pandigital products}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 45228. \textit{Solved: Sat, 8 Aug 2015, 17:14}.

\textbf{Math knowledge used}: basic modular arithmetic.

\textbf{Programming techniques used}: none.

This is a bit tedious, but the culling process is interesting. First, about the sizes of the numbers: the only valid sizes are $\paren2\times\paren3=\paren4$ and $\paren1\times\paren4=\paren4$. Just iterating over these sizes is enough (less than $20000$ products, not bad), but we can cull even more if we take into account that the moduli of the products have to verify $n1+n2+(n1\cdot n2)\equiv0$ (mod $9$). This leaves jsut a few cases: $\paren{1,4}$, $\paren{3,6}$, $\paren{7,7}$ and $\paren{0,0}$. In the first two cases we also need to consider the reverse pairs, $\paren{4,1}$ and $\paren{6,3}$. So, for each combination of (pair of sizes) and (pair of moduli) we generate the possible pairs using a mere arithmetic progression, and we verify the products. So for each pair or arithmetic progression we have a nested loop, and we can cull a bit further by breaking the inner loop when we hit a product with more than $4$ digits.

The program takes a bit to write but it's very fast. There aren't too many solutions:
\begin{itemize}
\item $4\cdot 1738=6952$.
\item $4\cdot 1963=7852$.
\item $28\cdot 157=4396$.
\item $12\cdot 483=5796$.
\item $39\cdot 186=7254$.
\item $48\cdot 159=7632$.
\item $42\cdot 138=5796$ (already found).
\item $18\cdot 297=5346$.
\item $27\cdot 198=5346$ (already found).
\end{itemize}

\section{Digit cancelling fractions}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 100. \textit{Solved: Sat, 8 Aug 2015, 17:25}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Obviously all the fractions have to be of the form $\frac{ab}{bc}$. So we just iterate over triples $\paren{a,b,c}$ (we can also assume $b>a$ and $b>c$), and we get the four results very quickly: $\frac{16}{64}=\frac14$, $\frac{19}{95}=\frac15$, $\frac{26}{65}=\frac25$ and $\frac{49}{98}=\frac48$. Then we accumulate the product of all the $\frac ac$ cases, getting $\frac8{800}=\frac1{100}$.





\end{document}
