\documentclass[a4paper,12pt]{article}

\usepackage[latin1]{inputenc}
\usepackage[spanish,es-tabla]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage{units}
\usepackage{color}
\usepackage{float}
\usepackage{longtable}
\usepackage{mathrsfs}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{relsize}
%\usepackage{mathabx}
\usepackage{ulem}

\bibliographystyle{alpha}

%\doublespacing
\clubpenalty=10000
\widowpenalty=10000

\DeclareMathOperator{\arccot}{arc\ cot}
\DeclareMathOperator{\arcsec}{arc\ sec}
\DeclareMathOperator{\arccsc}{arc\ csc}
\DeclareMathOperator{\sech}{sech}
\DeclareMathOperator{\csch}{csch}
\DeclareMathOperator{\argsenh}{arg\ senh}
\DeclareMathOperator{\argcosh}{arg\ cosh}
\DeclareMathOperator{\argtgh}{arg\ tgh}
\DeclareMathOperator{\argcoth}{arg\ coth}
\DeclareMathOperator{\argsech}{arg\ sech}
\DeclareMathOperator{\argcsch}{arg\ csch}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\mcd}{mcd}
\DeclareMathOperator{\modX}{m\acute od}
\DeclareMathOperator{\Cov}{Cov}

\pgfplotsset{compat=1.12}

\begin{document}

\newlength{\origpar}
\setlength{\origpar}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\parindent}{\origpar}

\renewcommand {\baselinestretch} {1.0}
\renewcommand*{\arraystretch}{1.5}

\newcommand{\paren}[1]{\ensuremath{\left(#1\right)}}
\newcommand{\corch}[1]{\ensuremath{\left[#1\right]}}
\newcommand{\llave}[1]{\ensuremath{\left\{#1\right\}}}
\newcommand{\angparen}[1]{\ensuremath{\left<#1\right>}}
\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\vecnorm}[1]{\ensuremath{\left|\left|#1\right|\right|}}
\newcommand{\pdiff}[2]{\ensuremath{\dfrac{\partial#1}{\partial#2}}}
\newcommand{\tlap}[1]{\ensuremath{\mathscr L\llave{#1}}}
\newcommand{\itlap}[1]{\ensuremath{\mathscr L^{-1}\llave{#1}}}
\newcommand{\Section}[1]{\renewcommand{\thesection}{#1}\section}
\newcommand{\floor}[1]{\ensuremath{\left\lfloor#1\right\rfloor}}
\newcommand{\ceil}[1]{\ensuremath{\left\lceil#1\right\rceil}}

\newcommand{\zm}[1]{\ensuremath{\mathbb Z/#1\mathbb Z}}

\definecolor{grey}{rgb}{0.50,0.50,0.50}
\definecolor{moradoesfruta}{rgb}{1,0,1}
\definecolor{orangeisthenewmorado}{rgb}{1,0.5,0}

\newcommand{\inRed}[1]{\textcolor{red}{#1}}
\newcommand{\inBlue}[1]{\textcolor{blue}{#1}}
\newcommand{\inGreen}[1]{\textcolor{green}{#1}}
\newcommand{\inPurple}[1]{\textcolor{moradoesfruta}{#1}}
\newcommand{\inOrange}[1]{\textcolor{orangeisthenewmorado}{#1}}

\newcommand{\SectionR}[1]{\renewcommand{\thesection}{\inRed{#1}}\section}
\newcommand{\SectionG}[1]{\renewcommand{\thesection}{\inGreen{#1}}\section}
\newcommand{\SectionO}[1]{\renewcommand{\thesection}{\inOrange{#1}}\section}

\newcommand{\matlab}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{black}{#1}}}\end{singlespace}}
\newcommand{\maxima}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{blue}{#1}}}\end{singlespace}}
\newcommand{\maximaoutput}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{grey}{#1}}}\end{singlespace}}
\newcommand{\scilab}[1]{\begin{singlespace}\noindent\footnotesize{\texttt{\textcolor{black}{#1}}}\end{singlespace}}

% Magia negra de Latex a continuación (copiada de http://tex.stackexchange.com/questions/44235/is-there-a-way-to-do-an-upside-down-widehat).
\makeatletter
\DeclareRobustCommand\widecheck[1]{{\mathpalette\@widecheck{#1}}}
\def\@widecheck#1#2{%
    \setbox\z@\hbox{\m@th$#1#2$}%
    \setbox\tw@\hbox{\m@th$#1%
       \widehat{%
          \vrule\@width\z@\@height\ht\z@
          \vrule\@height\z@\@width\wd\z@}$}%
    \dp\tw@-\ht\z@
    \@tempdima\ht\z@ \advance\@tempdima2\ht\tw@ \divide\@tempdima\thr@@
    \setbox\tw@\hbox{%
       \raise\@tempdima\hbox{\scalebox{1}[-1]{\lower\@tempdima\box
\tw@}}}%
    {\ooalign{\box\tw@ \cr \box\z@}}}
\makeatother
% Fin de la magia negra.

\setcounter{secnumdepth}{3}
\section{Multiples of 3 and 5}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 233168. \textit{Solved: Sat, 8 Aug 2015, 08:09}.

\textbf{Math knowledge used}: triangular numbers.

\textbf{Programming techniques used}: none.

It's very simple using inclusion-exclusion. We count how many multiples of $3$, $5$ and $15$ are there, then we use triangular numbers to determine each sum, then we return $\mathrm{sum}\paren3+\mathrm{sum}\paren5-\mathrm{sum}\paren{15}$.

\section{Even Fibonacci numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4613732. \textit{Solved: Sat, 8 Aug 2015, 08:23}.

\textbf{Math knowledge used}: recurrence equation theory.

\textbf{Programming techniques used}: none.

You can bruteforce this very easily. Or you can use recurrence equations! Which is of course my preferred method since it's more mathematical and, much more importantly, more scalable.

So, fibonacci numbers follow this formula:
\begin{equation*}
f\paren n=\dfrac{\varphi^n-\paren{1-\varphi}^n}{\sqrt5}.
\end{equation*}

And even fibonacci numbers are precisely those for which $n=\dot3$. That is, the numbers we are looking for follow this other formula:
\begin{equation*}
f_{\mathrm even}\paren n=\dfrac{\varphi^{3n}-\paren{1-\varphi}^{3n}}{\sqrt5}.
\end{equation*}

From this, considering that $\paren{1-\varphi}^{3n}$ tends to $0$ very rapidly, and calling $L=4e6$ the imposed limit, we can get a suitable formula for the largest $n$ we need:
\begin{equation*}
N=\floor{\dfrac{\log L}{3\log\varphi}}.
\end{equation*}

Finally, since we need the sum, we use a basic summation formula (again, considering that the $\paren{1-\varphi}^{3n}$ terms tend quickly to zero):
\begin{equation*}
\sum_{i=0}^n\dfrac{\varphi^{3n}-\paren{1-\varphi}^{3n}}{\sqrt5}\approx\sum_{i=0}^n\dfrac{\varphi^{3n}}{\sqrt5}=\dfrac{\varphi^{3n+3}-\varphi^3}{\paren{\varphi^3-1}\sqrt5}.
\end{equation*}
Rounding this value into the nearest integer we get the solution.

\section{Largest prime factor}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 6857. \textit{Solved: Sat, 8 Aug 2015, 08:33}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

Very simple, just enumerate all the primes up to $\sqrt L$ (with $L$ being the limit) and then divide until either we hit $1$ (meaning that the last prime we divided by is the result) or we run out of primes (meaning that the remaining number is the last prime we're looking for).

There are many methods that can be used to iterate over the primes, but the Erathostenes sieve is good enough. Saying that it will be used profusely is a big, big understatement.

\section{Largest palindrome product}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 906609. \textit{Solved: Sat, 8 Aug 2015, 08:39}.

\textbf{Math knowledge used}: modular arithmetic.

\textbf{Programming techniques used}: none.

The ``modular arithmetic'' I'm referring to is just the fact that I know that all palindrome numbers with an even amount of digits are multiples of $11$. So, the method to found this answer is as simple as iterating downwards over a pair of factors, but this bit of knowledge allows me to reduce the search space by 11, because one of the factors iterates over just multiples of $11$.

\section{Smallest multiple}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 232792560. \textit{Solved: Sat, 8 Aug 2015, 08:49}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve (for divisor generation).

\textbf{Programming techniques used}: none.

I'm not sure if ``none'' qualifies as the list of special knowledge used. I just factored all the numbers and then calculated the least common multiple in a more or less intelligent way (i.e. I have the factors, so no need to use Euclid's algorithm). This is the first time I used my DivisorHolder class, which is used for a fuckton of problems all over the list.

\section{Sum square difference}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 25164150. \textit{Solved: Sat, 8 Aug 2015, 08:54}.

\textbf{Math knowledge used}: basic Faulhaber formulas.

\textbf{Programming techniques used}: none.

The sum of all natural numbers up to $n$ is $\dfrac{n\paren{n+1}}2$, and if we square this we get:
\begin{equation*}
f\paren n=\dfrac{n^4+2n^3+n^2}4.
\end{equation*}

On the other hand, the sum of the squares of all the natural numbers up to $n$ is
\begin{equation*}
g\paren n=\dfrac{2n^3+3n^2+n}6.
\end{equation*}

Subtracting both numbers we get the formula we need:
\begin{equation*}
f\paren n-g\paren n=\dfrac{3n^4+2n^3-3n^2-2n}{12}.
\end{equation*}

Plugging in $n=100$ we get the result. By the way, it can be easily proven that despite the denominator this number is always an integer.

\section{10001st prime}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 104743. \textit{Solved: Sat, 8 Aug 2015, 09:02}.

\textbf{Math knowledge used}: Erathostenes sieve, $\pi\paren n$ counting function.

\textbf{Programming techniques used}: none.

Just use an Erathostenes sieve. As for the limit, we know that $\pi\paren x\approx\dfrac x{\log x}$, so if the limit is $L=10001$, then we can use $N=2L\log L$ (multiplying times $2$ is a safe addition. The formula I gave means that $x\approx\log x\cdot\pi\paren x$, but we have $\pi x$, and this formula doesn't say anything about $\log\pi\paren x\cdot\pi\paren x$). Then just move over the sieve until we have passed over $L$ primes.

\section{Largest product in a series}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 23514624000. \textit{Solved: Sat, 8 Aug 2015, 09:11}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

This is more algorithmic than mathematic, but still, it's not like it has much algoritmic depth. You can either iterate over the list, taking care about how the zeros break the chains, or just split the string into smaller strings of digits using the $0$ as separator, so that the remaining strings are safer to iterate. In any case the search algorithm is basically obvious (take the first $N$ digits as product, then at each step divide by the $\paren{i-N}$-th and multiply by the $i$-th. Take the maximum you found).

\section{Special Pythagorean triplet}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 31875000. \textit{Solved: Sat, 8 Aug 2015, 09:20}.

\textbf{Math knowledge used}: Pythagorean triples generation.

\textbf{Programming techniques used}: none.

So, this is the first problem that uses Pythagorean triple generation, another staple of Project Euler (not nearly as ubiquitous as prime generation, but still). This problem is very simple: if we can reliably generate all the primitives, then we will find some primitive so that $a+b+c=k$ and $N=1000$ is a multiple of $k$, $N/k=q\in\mathbb N$. In that case, we scale the triple to get $\paren{qa,qb,qc}$ so that $qa+qb+qc=1000$, and so the answer is $\paren{qa}\paren{qb}\paren{qc}=q^3abc$. By the way, the solution is the triple $\paren{15,8,17}$, which gets scaled into $\paren{375,200,425}$.

\section{Summation of primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 142913828922. \textit{Solved: Sat, 8 Aug 2015, 09:42}.

\textbf{Math knowledge used}: Prime summation function.

\textbf{Programming techniques used}: none.

This is an \textit{absolutely awesome} problem, disguised as a boring tutorial. Now, in certain way I could say the same about problem 2, right? But in that case, the interesting technique is very widely known and available to every first year maths student. In this case the magic is a little more obscure, although it's still very useful all over Project Euler.

So, the magic is that there is a recursive function that calculates the sum of primes in something like $O\paren{n^{2/3}}$ time, meaning that the result of this problem takes about $30$ milliseconds to get, AND that if I want to calculate the sum of all primes up to, say, $10^{12}$, it's perfectly doable. No need to generate all the primes explicitly. Yes, this \textit{will} be used (sparingly, but decisively) all over Project Euler.

Credits for this awesome function go to user \textbf{Lucy\_Hedgehog} of Project Euler. The algorithm itself is described in the comments of the problem, in what could very well be the highest rated comment of all the site.

\section{Largest product in a grid}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 70600674. \textit{Solved: Sat, 8 Aug 2015, 10:23}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Just a rehash of problem 8, more complicated because there are a lot more lines to take into account. This is purely algorithmic but it's more grit than anything. What I did was:
\begin{enumerate}[1.]
\item Parse the input into a 2D int array.
\item Generate all the horizontal, vertical and diagonal (in both directions) lines.
\item For each one of the generated lines, separate them into zero-less chunks, discarding the ones that are too short.
\item Get the maximum product of each of these chunks, using the very same function as in problem 8.
\item The maximum of all chunks' maxima is the result.
\end{enumerate}

\section{Highly divisible triangular number}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 76576500. \textit{Solved: Sat, 8 Aug 2015, 11:00}.

\textbf{Math knowledge used}: triangular numbers, ``first prime'' Erathostenes sieve (for divisor generation).

\textbf{Programming techniques used}: none.

Very easy. For each $N\geq2$, get the prime factorization of both $N-1$ and $N$, combine them, then remove a $2$. Count the amount of divisors of the resulting number, and if it's greater than the limit, return the number $\dfrac{N\paren{N-1}}2$. All of this can be reliably done with my DivisorHolder class that keeps the factorization using an IntIntMap.

By the way, the answer comes from $N=12376$, i.e. from $T\paren{12375}$. $12375=3^2\cdot5^3\cdot11$ and $12376=2^3\cdot7\cdot13\cdot17$, so the resulting triangular number is $2^2\cdot3^2\cdot5^3\cdot7\cdot11\cdot13\cdot17$, which has $3\cdot3\cdot4\cdot2\cdot2\cdot2\cdot2=576$ divisors.

\section{Large sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 5537376230. \textit{Solved: Sat, 8 Aug 2015, 11:30}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I wouldn't call the usage of BigInteger a ``programming technique''. In the end this problem isn't even algorithmic. On the good side, this is a good example of the advantage of Java Streams, since I can do all the additions without resorting to an explicit list of BigInteger; the original stream of lines returned by Files.lines can be used directly. Yay, I guess.

In most Project Euler problems, and that includes this one, the usage of BigInteger (or integers larger than 64 bits, for that matter) is not strictly unneeded. Still, there are many problems where they come in very handy.

\section{Longest Collatz sequence}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 837799. \textit{Solved: Sat, 8 Aug 2015, 11:54}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: memoization.

This can be done without memoization, but it's super slow. With memoization, it takes less than half a second, which is much more than anything before this problem but it's still short and sweet.

\section{Lattice paths}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 137846528820. \textit{Solved: Sat, 8 Aug 2015, 11:59}.

\textbf{Math knowledge used}: combinatorial numbers.

\textbf{Programming techniques used}: none.

Very simple. The amount of routes is just the amount of permutations between $20$ displacements to the right and $20$ displacements to the bottom. Therefore the result is $\displaystyle\binom{20+20}{20}$.

Of course, you can also try to manually enumerate all the possible paths. Good luck. This might be the first problem where, if you are \textit{completely} clueless, there's no way you are going to get the result.

\section{Power digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1366. \textit{Solved: Sat, 8 Aug 2015, 12:18}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: binary exponentiation.

This is one of the very few cases where I don't think you can solve this problem without resorting to a BigInteger or to a similar trick like a string of digits. It's not like it's much of a problem, though.

I'm counting binary exponentiation as a programming technique, although it's a very simple one (and arguably you could put into the ``mathematical knowledge'' bin). This will also be used very often all over Project Euler.

\section{Number letter counts}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 21124. \textit{Solved: Sat, 8 Aug 2015, 12:37}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I'm a bit torn about this problem. On one hand, the concept is kind of beautiful. I'm almost tempted to solve it in different languages like German or Finnish. On the other hand, coding it was repetitive and tedious.

The obvious way to solve this problem is generating all the strings and counting all the letters. Super-tedious. What I did was different: I enumerated all the words and then counted, for each one, in how many words appeared (all the cases are reasonably simple). Multiplying by the word's length, and adding the results, yields the solution.

\section{Number letter counts}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1074. \textit{Solved: Sat, 8 Aug 2015, 13:03}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: greedy algorithm.

Finally some actual algorithmics, even if very simple. A greedy algorithm that gets the best sum from both ``parents'' from above is good enough.

\section{Counting Sundays}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 171. \textit{Solved: Sat, 8 Aug 2015, 13:14}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

This is stupidly simple but I kept getting the wrong result because I used a monday as a starting point, but this is not what I need to use since I must count from 1901 onwards and the date I'm given is from 1900, not 1901.

The method itself: well, there are only 14 types of years. So I count how many of each type are there in the period from 1901 to 2000, then for each year type I count how many months start on a Sunday. Multiply and accumulate the sum. End.

\section{Factorial digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 648. \textit{Solved: Sat, 8 Aug 2015, 13:16}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Similar to problem 16, but even more simple because there is no binary exponentiation, just creating the factorial and adding the digits. Not much more to add, except that this is one of the cases where BigInteger or equivalent is really, actually needed.

\section{Amicable numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 31626. \textit{Solved: Sat, 8 Aug 2015, 13:40}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve (for divisor generation), divisor sum properties.

\textbf{Programming techniques used}: memoization.

The formula I've listed under ``divisor sum properties'' is the following: if a number's prime decomposition is
\begin{equation*}
N=\prod_{i=1}^mp_i^{e^i},
\end{equation*}
then the sum of its divisors is
\begin{equation*}
S\paren N=\prod_{i=1}^m\dfrac{p_i^{e^i+1}-1}{p_i-1}.
\end{equation*}
So the proper sum of divisors is $S\paren N-N$, and that's all the maths needed for this problem. So we keep two maps of $N\rightarrow S\paren N-N$, one with the abundant numbers ($S\paren N>2N$) and another one with the defective numbers ($S\paren N<2N$). No need to store perfect numbers. Then we iterate over the abundant numbers map (which is the smaller of the two), looking for entries where the key-value pair appears as value-key in the defective map. Of course, a single map can be used with all the numbers, but it will be slightly slower.

\section{Names scores}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 871198282. \textit{Solved: Sat, 8 Aug 2015, 14:05}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Yeah, I refuse to call a sort function a ``programming technique''. I don't like this problem, mostly because it's too streamlined and basically the description tells you exactly what to do. No room for finesse or for improvements. Just read the (single line) file, parse it into a list of names, sort it, then use the given algorithm to calculate the result.

\section{Non-abundant sums}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4179871. \textit{Solved: Sat, 8 Aug 2015, 14:20}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve (for divisor generation), divisor sum properties.

\textbf{Programming techniques used}: none.

Using the same divisor function as in problem 21, the algorithm is simple: generate the set all the abundant numbers up to the given limit using said numbers, then generate all the possible sums of two values of the set below the limit. Then iterate over all the numbers up to the limit and add them to a tally if they are not in the set of sums. There is a modicum of brute force in the sum generation process so this takes nearly half a second.

\section{Lexicographic permutations}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 2783915460. \textit{Solved: Sat, 8 Aug 2015, 14:36}.

\textbf{Math knowledge used}: factorial number system.

\textbf{Programming techniques used}: none.

I said that I didn't like 22, right? 24 is the opposite. It's very nice, and for such an early problem, it has room for a clever usage of maths that eschews brute force. I could have replaced the math knowledge about the factoradic system with programming technique about permutation enumeration, but that would require a million operations, while using factoradic requires ten, and probably faster ones.

In a nutshell: you can either enumerate a million partitions (slow) or just represent $10^6-1$ in factoradic (fast!). I obviously opted for the second way.

\section{1000-digit Fibonacci number}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4782. \textit{Solved: Sat, 8 Aug 2015, 14:41}.

\textbf{Math knowledge used}: recurrence equation theory.

\textbf{Programming techniques used}: none.

Just like in problem 2, we can use the formula
\begin{equation*}
F_n=\dfrac{\varphi^n-\paren{1-\varphi}^n}{\sqrt5}\approx\dfrac{\varphi^n}{\sqrt5}.
\end{equation*}
We need to calculate the first $n$ so that $F_n\geq10^{1000-1}$ (note that $10^{1000}$ has \textit{1001} digits, not 1000). Solving for $n$ we get:
\begin{equation*}
\dfrac{\varphi^n}{\sqrt5}\geq10^{999}\Rightarrow n\geq\dfrac{999\log10+\log\sqrt5}{\log\varphi}\Rightarrow n=\ceil{\dfrac{999\log10+\log\sqrt5}{\log\varphi}}.
\end{equation*}
Of course this calculation is super fast, on par with the first two problems in speed.

\section{Reciprocal cycles}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 983. \textit{Solved: Sat, 8 Aug 2015, 15:03}.

\textbf{Math knowledge used}: infinite decimal period distributions.

\textbf{Programming techniques used}: none.

The keys to this algorithm are two: the first one is that the period length of $1/n$ can only have as much as $n-1$ digits; the second one is that $n-1$ is only reached, in fact, if $n$ is prime. While it's not strictly true that the result \textit{needs} to be a prime, it's very likely, so I just iterated downwards over the primes, calculating the cycle length and stopping whenever the current value was smaller than the greatest length found. The result is found almost instantly (less than 1ms) because the result is close to the limit.

\section{Quadratic primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: -59231. \textit{Solved: Sat, 8 Aug 2015, 15:20}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

The only useful insight for this problem is that $b$ has to be a prime, otherwise of course we don't get any prime because for $n=0$ the polynomial doesn't yield a prime and we stop immediately. Also, once this is taken care of, we can start the iterations from $n=1$ instead of $n=0$ since of course we got a prime for $n=0$. This shaves some... nanoseconds? from the run time. Another nano-optimization is calculating the polynomial value by incrementing the previous value in $2n+a-1$, instead of calculating the complete value each time. Aside from all that swill, this is just iterating over $\corch{-L\ldots L}$ for $a$, and over the primes smaller than $L$ for $b$, and then calculating the polynomial values. By the way, the solution is reached for $a=-61$, $b=971$, for a total of $71$ primes.

\section{Number spiral diagonals}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 669171001. \textit{Solved: Sat, 8 Aug 2015, 15:34}.

\textbf{Math knowledge used}: basic Faulhaber formulas.

\textbf{Programming techniques used}: none.

Another hyper-fast one. Sure, you can iterate over the numbers and build the spiral manually or whatever, but why do that when each half diagonal follows a very clear formula? So, if the length we are looking for is $L=1001$, the half diagonals have a size of $N=\dfrac{L-1}2=500$. The formulas for the half diagonal numbers are very simple:
\begin{eqnarray*}
F_1\paren n&=&4n^2-2n+1;\\
F_2\paren n&=&4n^2+1;\\
F_3\paren n&=&4n^2+2n+1;\\
F_4\paren n&=&4n^2+4n+1.
\end{eqnarray*}
The sum of all these values is $S\paren n=16n^2+4n+4$, so the result of the problem is
\begin{equation*}
1+\sum_{n=1}^N\paren{16n^2+4n+4}=1+4N+4\sum_{n=1}^Nn+16\sum_{n=1}^Nn^2.
\end{equation*}
With the Faulhaber formulas for $k=1$ and $2$ we can summarize this result as
\begin{equation*}
1+\dfrac{32N^3+60N^2+52N}6.
\end{equation*}
Plugging $N=500$ yields the result.

Side note: I'm slightly triggered by the fact that the spiral moves in \sout{clockwise}negative direction.

\section{Distinct powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 9183. \textit{Solved: Sat, 8 Aug 2015, 15:46}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

I overengineered this problem in order to make a generic algorithm that would work for bigger values. It was \textit{delightful}.

The obvious algorithm generates all the algorithm (using BigInteger, or logarithms, or whatever). Instead, what I did was counting the amount of powers of each type present in the algorithm, and for each of them, I counted the new exponents that each type could generate. In the given range there are $87$ normal numbers ($99$ new values each), $6$ square numbers ($50$ new values each), $2$ cubes ($50$ new values each), $2$ fourth powers ($41$ new values each), and a fifth and a sixth power ($51$ and $37$ new values respectively). So: $87\cdot99+6\cdot50+2\cdot50+2\cdot41+51+37=9183$.

\section{Digit fifth powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 443839. \textit{Solved: Sat, 8 Aug 2015, 16:13}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: combination generation (with repetition).

Ah, yes. Reusing pays. I have a generic combination generator which is \textit{very useful} since there are a lot of problems that require generating all the \textit{unordered} combinations of certain set of values. I started it long ago and it's currently refined into a very reasonable, fast and usable class. So, with that generator in my hands, I just need to generate all \textit{six} or less combinations of numbers between $0$ and $9$, and for each of them, verify whether the sum of fifth of powers matches the combination. Why six digits, precisely? Because for seven digits we can't get numbers, because the maximum valus is below the minimum: $7\cdot9^5<10^{7-1}$. For six digits it happens that $6\cdot9^5\geq10^{6-1}$, so they must be taken into account.

There are six such numbers: $4150$, $4151$, $93084$, $92727$, $54748$ and $194979$. See, I told you, six digits are needed.

\section{Coin sums}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 73682. \textit{Solved: Sat, 8 Aug 2015, 16:29}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: dynamic programming.

Classic dynamic programming problem. Only two arrays need to be kept at each time: the previous one, $P$, which for each index $i$ contains the amount of ways to sum up to $i$ using all the previously visited coins, and the new one, $N$, associated to the new coin with value $c$, which we generate like this:
\begin{equation*}
N\corch i=\sum_{k=0}^{\floor{\frac ic}}P\corch{i-kc}.
\end{equation*}
The first array for $c=1$ is all ones, and then we iterate for each one of the remaining coins, $c\in\llave{2,5,10,20,50,100,200}$. The problem solution is the value for index $200$ in the last array.

\section{Pandigital products}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 45228. \textit{Solved: Sat, 8 Aug 2015, 17:14}.

\textbf{Math knowledge used}: basic modular arithmetic.

\textbf{Programming techniques used}: none.

This is a bit tedious, but the culling process is interesting. First, about the sizes of the numbers: the only valid sizes are $\paren2\times\paren3=\paren4$ and $\paren1\times\paren4=\paren4$. Just iterating over these sizes is enough (less than $20000$ products, not bad), but we can cull even more if we take into account that the moduli of the products have to verify $n1+n2+(n1\cdot n2)\equiv0$ (mod $9$). This leaves jsut a few cases: $\paren{1,4}$, $\paren{3,6}$, $\paren{7,7}$ and $\paren{0,0}$. In the first two cases we also need to consider the reverse pairs, $\paren{4,1}$ and $\paren{6,3}$. So, for each combination of (pair of sizes) and (pair of moduli) we generate the possible pairs using a mere arithmetic progression, and we verify the products. So for each pair or arithmetic progression we have a nested loop, and we can cull a bit further by breaking the inner loop when we hit a product with more than $4$ digits.

The program takes a bit to write but it's very fast. There aren't too many solutions:
\begin{itemize}
\item $4\cdot 1738=6952$.
\item $4\cdot 1963=7852$.
\item $28\cdot 157=4396$.
\item $12\cdot 483=5796$.
\item $39\cdot 186=7254$.
\item $48\cdot 159=7632$.
\item $42\cdot 138=5796$ (already found).
\item $18\cdot 297=5346$.
\item $27\cdot 198=5346$ (already found).
\end{itemize}

\section{Digit cancelling fractions}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 100. \textit{Solved: Sat, 8 Aug 2015, 17:25}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Obviously all the fractions have to be of the form $\frac{ab}{bc}$. So we just iterate over triples $\paren{a,b,c}$ (we can also assume $b>a$ and $b>c$), and we get the four results very quickly: $\frac{16}{64}=\frac14$, $\frac{19}{95}=\frac15$, $\frac{26}{65}=\frac25$ and $\frac{49}{98}=\frac48$. Then we accumulate the product of all the $\frac ac$ cases, getting $\frac8{800}=\frac1{100}$.

\section{Digit factorials}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 40730. \textit{Solved: Sat, 8 Aug 2015, 17:30}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: combination generation (with repetition).

This is a lot like problem 30, but here I needed to take care about leading zeros. This wasn't a problem in 30 because $0^5=0$, but here we have $0!=1$ so I need to subtract excess leading zeros. Aside from that, the code is almost identical (I need to use up to 7 digits since $9!\cdot7\geq10^{7-1}$, but $9!\cdot8<10^{8-1}$).

There are only two solutions: $145=1+24+120$ and $40585=24+1+120+40320+120$.

\section{Circular primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 55. \textit{Solved: Sat, 8 Aug 2015, 18:05}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: custom combination generation.

They are starting to get tricky. It's not that this is impossible or something, but we need to start taking care about things like generating numbers efficiently (well, not really. This is still bruteforceable), avoiding repetition and so on. I created a custom combination class that I expect to use often.

Anyway: the cases for 1 digit are handled separately (i.e. just add 4 to the final result). As for the rest, I generate all the combinations of odd numbers with $N$ digits, for $N\in\corch{2,6}$, and for each combination, I search for primality in all the generated circular numbers. Not that difficult, but laborious.

\section{Double-base palindromes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 872187. \textit{Solved: Sat, 8 Aug 2015, 18:40}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

The easiest way to do this, by far, is to generate all the palindromes in base $10$ and then check whether they are palindromes in base $2$. And in order to generate palindromes in base $10$, we just generate ``half'' of the palindrome (the bottom numbers) and mirror the rest. A bit of cleverness is needed about the leading zeroes, but nothing tough.

\section{Truncatable primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 748317. \textit{Solved: Sat, 8 Aug 2015, 19:01}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: custom combination generator.

I don't think that providing an explicit limit for the Eraatahostenes sieve is cheating or anything like that. If I had found fewer than $11$ primes, I would have increased the amount of digits.

Anyway: I generate all the candidates (numbers that can start with any odd number or 2, and where the rest of the digits are odd and not $5$), and for each of them, I check whether they are truncatable with the help of a premade Erathostenes sieve. Not much more complicated than that.

The truncatable primes are: $23$, $37$ (of course!), $53$, $73$, $313$, $317$, $373$, $797$, $3137$, $3797$ and $739397$.

\section{Pandigital multiples}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 932718654. \textit{Solved: Sat, 8 Aug 2015, 19:09}.

\textbf{Math knowledge used}: modular arithmetic.

\textbf{Programming techniques used}: none.

This can be solved incredibly fast with the help of some previous analysis.
\begin{itemize}
\item We already know a number: $918273645$, which conveniently starts with a $9$, reducing the search space by a lot. Also no other $1$ digit starting number can be greater than this since obviously it would be smaller than $9$.
\item For two digit numbers, they must verify that $3x<100$ and $4x\geq100$ so that the concatenation has $9$ digits. This means that $25\leq x<34$ and therefore the resulting number will never be greater than the known case.
\item For three digit numbers, they have to verify $3x<1000$, so $x<334$ and there's no way they can be greater than the known case.
\item For four digit numbers we need to verify some cases. The only restriction is $2x\geq10000$. Also we don't need to look further than $9182$. Finally, the number must be a multiple of $3$ so that the concatenation of $x$ and $2x$ is a multiple of 9 (this bit is the ``modular arithmetic'' knowledge mentioned above).
\end{itemize}
So we can just iterate from $9999$ to $9183$ in intervals of $-3$, return immediately if $\paren{10^5+2}x$ is pandigital, and return $918273645$ if we don't find any.

\section{Integer right triangles}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 840. \textit{Solved: Sat, 8 Aug 2015, 19:21}.

\textbf{Math knowledge used}: Pythagorean triples generation.

\textbf{Programming techniques used}: none.

We need to generate all the primitive Pythagorean triples with perimeter smaller or equal than the given amount, and then for each perimeter $p$ we increase counters for all the multiples of $p$ below the limit (since the triangle can be scaled). Then we iterate over the counters and return the one where the index is the highest, which is $840$ with a measly $8$ solutions.

\section{Champernowne's constant}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 210. \textit{Solved: Sat, 8 Aug 2015, 19:30}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

It's all about being careful about how numbers are being generated. I divided the decimals in ``chunks'' of numbers with fixed amounts of digits: $9$ with $1$ digit, $90$ with $2$, and so on. In the end:
\begin{itemize}
\item The $1$st digit is $1$, of course.
\item The $10$th digit is the $1$ in $10$.
\item The $100$th digit is the first $5$ (tens) in $55$.
\item The $1000$th digit is the $3$ in $370$.
\item The $10000$th digit is the unit $7$ in $2777$.
\item The $100000$th digit is the $2$ in the thousands from $22222$.
\item Finally, the millionth digit is the first one (hundreds of thousands) from $185185$.
\end{itemize}
It takes a bit too long ($25$ milliseconds), for something that can be reasonably done by hand in a couple minutes top.

\section{Pandigital prime}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 7652413. \textit{Solved: Sat, 8 Aug 2015, 20:17}.

\textbf{Math knowledge used}: Miller-Rabin primality test.

\textbf{Programming techniques used}: permutation iterator.

This is the first usage of the robust permutation iterator based on C++'s next\_permutation. The algorithm is quite simple: for each amount of digits, iterate downwards over all the possible digit permutations, and then return the first prime found. Using Miller-Rabin for the primality test, just like I could have used a (kind of big) Erathostenes sieve.

The only sizes we need to iterate over are $1$, $4$ and $7$, since otherwise the sum of the first $N$ digits is a multiple of $3$, so the resulting number is never a prime. Obviously the result has $7$ digits.

\section{Coded triangle numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 162. \textit{Solved: Sat, 8 Aug 2015, 20:23}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Very boring, not much substance. Let's see: suppose that $K$ is a hypothetical triangular number. In that case, some integer $n$ verifies:
\begin{equation*}
\dfrac{n^2+n}2=K\Rightarrow n^2+n-2K=0\Rightarrow n=\dfrac{-1\pm\sqrt{1+8K}}2.
\end{equation*}
Now, if the square root is exact, it must be an odd number, so after subtracting 1 we get an even one so we can divide by two. In other words, if the square root is exact, then $n$ is an integer, which means that $K$ is a triangular number if an only if $1+8K$ is a perfect square.

The algorithm is clear and it doesn't offer much room for improvement: read all the words, calculate their ``value'' shamelessly reusing code from problem 22, and verify whether their value verifies the condition above.

\section{Sub-string divisibility}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 16695334890. \textit{Solved: Sat, 8 Aug 2015, 21:09}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

After the previous boring problem, this one is much more fun. The analysis can be done by hand:
\begin{itemize}
\item $d_4d_5d_6$ is a multiple of $5$, therefore $d_6$ is either $0$ or $5$.
\item However, if $d_6=0$, then $d_6d_7d_8=0d_7d_8$, which is only a multiple of $11$ if $d_7=d_8$, which can not happen. So $d_6=5$.
\item Now we have several possible cases for $d_7d_8$, considering that $5d_7d_8$ must be a multiple of $11$:
\begin{itemize}
\item $d_7d_8=06$. In this case, $d_9=5$ so that $065$ is a multiple of $13$, but we have already used the $5$, so this is not valid.
\item $d_7d_8=17$. There is no three digit multiple of $13$ starting with $17$, so es geht nicht.
\item $d_7d_8=28$. This forces $d_9=6$ and $d_{10}=7$. Nice so far. Also $d_5$ has to be $9$ (it could be $2$, but we already used it). And looking at $d_3d_4d_5$, we know that $\llave{d_3,d_4}=\llave{0,3}$ so that we get a multiple of $3$. Since $d_4$ must be even, necessarily we get $d_4=0$, $d_3=3$. So we get $d_1d_230952867$ where $\llave{d_1,d_2}=\llave{1,4}$. Great!
\item $d_7d_8=39$. Then $d_9=0$ and there is no suitable value for $d_{10}$.
\item $d_7d_8=50$ is not valid because we already are using $5$.
\item $d_7d_8=61$. The only valid value is $d_9=1$, not available.
\item $d_7d_8=72$. We need $d_9=8$ and $d_{10}=9$. On the other hand $d_5$ must be $3$. To get a multiple of 3 we need that $\llave{d_3,d_4}=\llave{0,6}$. And $\llave{d_1,d_2}=\llave{1,4}$. This gets us four further solutions. Nice!
\item $d_7d_8=83$. So $d_9=2$ and $d_{10}=3$. Oops.
\item $d_7d_8=94$. $d_9=9$, already used.
\end{itemize}
\item So we already got the $6$ cases and no programming is needed!
\end{itemize}
This is a remarkable problem, in that it can be very easily analysed by hand completely. These are rare, but always fun.

\section{Pentagon numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 5482660. \textit{Solved: Sat, 8 Aug 2015, 21:29}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Another problem that I don't quite like. It's not like it's super slow or anything, but the lack of a proper limit bothers me. Anyway, the steps I followed where these: generate successive pentagonal numbers $p_i$, and for each $j<i$, verify whether $D=p_i-p_j$ is pentagonal (by looking it up in the set of previously generated) and whether $S=p_i+p_j$ is also pentagonal (by checking that $\dfrac{1+\sqrt{24S+1}}6$ is an integer). If both conditions hold, return $D$.

\section{Triangular, pentagonal, and hexagonal}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 1533776805. \textit{Solved: Sun, 9 Aug 2015, 09:03}.

\textbf{Math knowledge used}: knowledge about polygonal numbers.

\textbf{Programming techniques used}: none.

Unlike the previous one, this one has room for mathematical analysis (aside from the trivial reversal of the pentagonal formula). The nice thing here, and something that apparently I hadn't realized the first time I solved this, is that every hexagonal number is also a triangular number! If we plug $2n-1$ in the formula of the triangular numbers we get:
\begin{equation*}
T_{2n-1}=\dfrac{\paren{2n}\paren{2n-1}}2=2n^2-n=H_n.
\end{equation*}
So the hexagonal numbers are precisely the odd triangular numbers. This means that we can solve this problem by generating hexagonal numbers and checking whether they are pentagonal. We could also do it the opposite way, but since hexagonal numbers are more spaced than pentagonal ones, by iterating this way we perform fewer checks. The result is $P_{31977}=H_{27693}$, so about one seventh of checks is saved.

\section{Goldbach's other conjecture}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 5777. \textit{Solved: Sun, 9 Aug 2015, 09:12}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

This can be done in several ways. What I did was: I set up a limit ($10^5$, high enough), then I used a sieve to get primes and composites. Then I iterate over all the squares, generating the sums of primes plus doubled squares, and finishing when any odd composite smaller than the current square hasn't been generated.

\section{Distinct primes factors}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 134043. \textit{Solved: Sun, 9 Aug 2015, 09:26}.

\textbf{Math knowledge used}: ``first prime'' Erathostenes sieve for divisor generation.

\textbf{Programming techniques used}: none.

Not much room for finesse aside from generating divisors reasonably cleverly. Just generate the divisors for every number, keeping track of numbers with exactly four different prime factors, and finish when four consecutive ones are found.

By the way:
\begin{itemize}
\item $134043=3\cdot7\cdot13\cdot491$.
\item $134044=2^2\cdot23\cdot31\cdot47$.
\item $134045=5\cdot17\cdot19\cdot83$.
\item $134046=2\cdot3^2\cdot11\cdot677$.
\end{itemize}

\section{Self powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 9110846700. \textit{Solved: Sun, 9 Aug 2015, 09:37}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: binary exponentiation.

For a veteran, this problem is a bit infuriating. This problems seems to lend itself easily to binary exponentiation, BUT since the modulus is greater than $2^{31.5}$, temporary results don't fit into a long. So either you eschew the speed of binary exponentiations or you eschew the speed of primitive longs. Since I had to bit the bullet anyway, I tried both approaches. To my surprise, doing full iterations with longs is faster than binary exponentiation with BigInteger. \textit{And faster than binary exponentiation with longs} (which returns the wrong results anyway), which is extra-surprising. Initially I assumed that this happens because the exponents are very small and because division is much slower than multiplication, but that's not true. The real issue, and this is super-interesting, is that calling code from a different class adds some overhead in terms of time! I knew that Java initialisation could be slow, but a delay of $10$ms for a single added class is much more time than I had thought.

\section{Self powers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 296962999629. \textit{Solved: Sun, 9 Aug 2015, 10:06}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

Not much to describe. Just iterate over all the primes from 1007 to 3339 (ok, this one is not a prime, but it's the upper limit), and for each one, verify whether $p+3330$ and $p+6660$ are also primes and have the same digits in different order. There is a bit of room for finesse, I think, but I haven't thought much about it. The program is super fast anyway.

\section{Consecutive prime sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 997651. \textit{Solved: Sun, 9 Aug 2015, 10:25}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: none.

This is a bit more interesting than it seems, because there is room for improvements. Obviously we need to iterate over sums of primes, and this can be done in several different ways. What I did was: iterate over primes, and then iterate over \textit{upper bounds} for indices in the array of primes. So, for each starting prime I could always start in an upper bound equal to $1$ plus the current upper bound. This sped up the process, and it ensured that every prime found by this method was a suitable candidate and I could update the current maximum length and the current maximum prime.

By the way, 997651 is the sum of $543$ primes, from $7$ to $3931$ included.

\section{Consecutive prime sum}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 121313. \textit{Solved: Sun, 9 Aug 2015, 13:03}.

\textbf{Math knowledge used}: Erathostenes sieve.

\textbf{Programming techniques used}: combination generator (with and without repetition).

What's that? A whopping 15\% difficulty rating! Quite the leap! Just joking, this is still pretty easy, but Project Euler is finally starting to be Project Euler. I think I also pulverized my own longest loop header, using a five-level nested loop in a single header:
\begin{itemize}
\item First we iterate by total amount of digits. Which goes from $5$ to infinity (fortunately the solution has just $6$).
\item The second iteration is over the amount of digits present in the ``variable'' group. Thanks to the pigeonhole principle we know that this digit group must have a length multiple of $3$, because otherwise the group of $10$ different candidates will have at least $3$ multiples of $3$ so there will not be $8$ primes.
\item Then we iterate over the \textit{positions} of the variable digits. In the case of the solution, $121313$, this refers to positions $0$, $2$ and $4$, since the primes are $x2x3x3$. We use a combination iterator without repetition for this.
\item Then we iterate over the fixed digits, save for the last one which is a special case. In this case we use a combination iterator with repetition.
\item Finally we iterate over the last digit, which must be $1$, $3$, $7$ or $9$ since we are looking for primes.
\end{itemize}
For each case, we will build the set of possible numbers ($9$ if the first digit is not variable, $10$ if it is) and we return as soon as we generate a set with $8$ or more primes. It's more complicated than most problems so far, but it's also reasonably simple and doable. It's not even optimal and still it has a little more than $50$ lines and runs in $34$ or $35$ milliseconds.

\section{Consecutive prime sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 142857. \textit{Solved: Sun, 9 Aug 2015, 12:33}.

\textbf{Math knowledge used}: infinite decimal period distributions.

\textbf{Programming techniques used}: none.

Uh... what the fuck is this? It can only have a solution. No programming required. I find this easier than problem $1$. You could as well ask me about how much is $1+2$.

\section{Consecutive prime sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 4075. \textit{Solved: Sun, 9 Aug 2015, 13:11}.

\textbf{Math knowledge used}: combinatorial numbers.

\textbf{Programming techniques used}: none.

There are a million (HA!) ways to do this. The one I use is, I think, possibly one of the fastest approaches. I started with a subarray of the combinatorial numbers $\displaystyle\binom{23}k$ for $k\in\corch{0,9}$, and then I iterated for $n\in\corch{24,100}$, generating at each step the subarray of combinatorial numbers that doesn't exceed the limit of one million. This can be done super fast because it's just a bunch of additions, and checking when the last number is going to surpass the limit (so I need to reduce the array) is quite trivial as well. Then, if this array has length $L$, it means that I have $2L$ combinatorials smaller than one million in this line, and so there must be $n+1-2L$ combinatorials \textit{over} a million. Adding this value for each $n$ yields the solution.

\section{Consecutive prime sum}
\textbf{Difficulty rating}: 10\%.

\textbf{Solution}: 376. \textit{Solved: Sun, 9 Aug 2015, 23:58}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Is this ugly? Is this beautiful? Not sure, really. It's very tedious because there are a lot of cases, but I think that the concept is reasonably interesting. The first time I read this problem, I did it in diagonal and thought about all the possible combinations in which player 1 wins (this is a challenge! But in the end it's about counting ties, subtracting from $\displaystyle\binom{54}{10}$ and dividing by two). The real problem is way, way less challenging. I have read somewhere that there are people who consider this problem to be very difficult! The only way I can understand this is if they are messing with all the cases, but for me this definitely doesn't qualify as difficult.

This is, so far, the problem which requires the largest code. By a wide margin.

\section{Lychrel numbers}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 249. \textit{Solved: Mon, 10 Aug 2015, 00:09}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Not much to add. There are ways to speed up the process (such as remembering the intermediate number, i.e. if I found the chain $49\rightarrow143\rightarrow484$ when looking for $49$, I shouldn't need to do the calculations for $143$; or noting that any number whose digits are strictly below $5$ will result in a palindrome immediately), but frankly it's not worth the hassle. The procedure is basically described in the problem: iterate, check, return if the last iteration hasn't found anything.

This problem warns my heart a little because it makes me nostalgic of certain very old maths book.

\section{Powerful digit sum}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 972. \textit{Solved: Mon, 10 Aug 2015, 00:15}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Another regression to the ``not really Project Euler'' tutorial problems. There seems to be room for improvement by being clever with culling, iterating downwards and returning early, but this doesn't pay much. Since the powers can be reused, speeding up each iteration, in the end it's just better to write the trivial problem: iterate $a$ and $b$ over the range, calculate the current power using $a\times a^{b-1}$ instead of recalculating the result anew each time, get the sum of digits.

\section{Square root convergents}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 153. \textit{Solved: Mon, 10 Aug 2015, 00:20}.

\textbf{Math knowledge used}: continued fractions and convergents.

\textbf{Programming techniques used}: none.

The fun begins! Project Euler still holds your hand, but it's getting ready for the main show. At this point it's reasonably easy to just follow the instructions, and you can even use doubles to get the periodic fraction (which is laughably simple), but since the convergents are going to be used from time to time (yes $192$ and $656$, I'm talking to you) and actual accuracy is required there, let's talk a bit about how to generate the periodic continued fraction of a square root.

The trivial calculations uses double precision without restriction. We define variables $x=\sqrt k$ and $l=\floor{x}$ ($l$ for ``\textbf{l}ast convergent''), and we iterate: at each step, $y=\dfrac1{x-l}$, and then we assign $x\leftarrow y$, $l\leftarrow\floor y$. If we are calculating the period of a square root, we end when we get $l=2\floor{\sqrt k}$ (yes, really). So far so good, right? The problem is that floating point numbers are really crappy, so around $n=130$ you will start getting problems, so a more careful analysis is necessary.

Where to start that careful analysis? It seems clear that both the numerator and the denominator are going to be elements from $\mathbb Q\corch{\sqrt n}$, so we can just model $x$ and $y$ as fractions of the form $\dfrac{A\sqrt n+B}{C\sqrt n+D}$. Let's call the succession of convergents $a_n$, because it will ease the reasoning. So $a_0=\floor{\sqrt n}$ and $a_1=\dfrac1{\sqrt x-a_0}$. Now, the basic iteration calculates the new terms as follows:
\begin{itemize}
\item $A_{n+1}=C_n$.
\item $B_{n+1}=D_n$.
\item $C_{n+1}=A_n-a_nC_n$.
\item $D_{n+1}=B_n-a_nD_n$.
\item $a_{n+1}=\floor{\dfrac{A_{n+1}\sqrt k+B_{n+1}}{C_{n+1}\sqrt k+D_{n+1}}}$.
\end{itemize}
This looks very promising! But... we will encounter precision problems \textit{even a bit before} than with the previous method, because floating point is a bitch. Oh, yes, the values for $A_n$, $B_n$, $C_n$ and $D_n$ will be correct because they use integer arithmetic, by which I mean BigInteger arithmetic. But in order to reduce precision problems regarding $a_n$, we need to rationalize the denominator. So, in order to actually calculate the convergents, we need to change the formula for $a_n$ into this one:
\begin{equation*}
a_n=\floor{\dfrac{\paren{B_nC_n-A_nD_n}\sqrt k+\paren{A_nC_nk-B_nD_n}}{C_n^2k-D_n^2}}.
\end{equation*}

It's a bit soon to write all this since this is not needed at all for problem $57$ (for which we only need to calculate $a_1=2$, which is even given as part of the problem description), but the convergent library is going to be the same for a few problems in the future.

Now, back to problem $57$. Yes, all that shit above doesn't mean much because the succession of terms in the periodic fraction is $a_n=\llave{2,2,2,\ldots}$. Now, how to \textit{really} calculate the convergents? As in, the whole $\dfrac pq$ fractions? The formula is quite simple. We call $a_0=\floor{\sqrt k}$ ($k=2$ in our case) and then $a_n$ starting in $n=1$ is the aforementioned succession. So, we define: $p_{-1}=1$; $q_{-1}=0$; $p_0=\floor{\sqrt k}$, $q_0=1$. The iterative process just follows the formulas $p_n=a_np_{n-1}+p_{n-2}$, $q_n=a_nq_{n-1}+q_{n-2}$. This is the general calculation that will be used often. Now, for problem $57$ specifically, we just need to calculate $\llave{p_n,q_n}$ for $k=2$ and $n\in\corch{1,1000}$ and count in how many cases $p_n$ has more digits than $q_n$. Which is far too simple and can be done using the imprecise double calculations, but then it wouldn't be reusable.

This explanation is too long for problem $57$, yes. However, it's not too long for problems $66$, $192$ or $656$.

\section{Spiral primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 26241. \textit{Solved: Mon, 10 Aug 2015, 10:23}.

\textbf{Math knowledge used}: Erathostenes sieve and Miller-Rabin primality test.

\textbf{Programming techniques used}: none.

Unlike that awful problem 28, this one spirals in the right, positive direction. The problem itself is pretty easy, because we can keep counters for each branch tip: $f_{\llave{1\ldots4}}={3,5,7,9}$ at the start, and then, starting with $i=4$ and in increments of two we can do $f_k=f_{k-1}+i$ (starting with $f_1=f_4+i$) and check primalities as we go.

This problem is the first one where my execution time exceeds half a second ($\approx0.6$s).

\section{Spiral primes}
\textbf{Difficulty rating}: 5\%.

\textbf{Solution}: 129448. \textit{Solved: Mon, 10 Aug 2015, 10:43}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Easy, but fun. The idea is that the english text will contain the string ``the'' many times. So for each password we will generate the decrypted string, and we will accept the one with the highest amount of appearances of ``the''. In the end, the password is ``exp'' and the text is this paragraph:

\textit{An extract taken from the introduction of one of Euler's most celebrated papers, "De summis serierum reciprocarum" [On the sums of series of reciprocals]: I have recently found, quite unexpectedly, an elegant expression for the entire sum of this series 1 + 1/4 + 1/9 + 1/16 + etc., which depends on the quadrature of the circle, so that if the true sum of this series is obtained, from it at once the quadrature of the circle follows. Namely, I have found that the sum of this series is a sixth part of the square of the perimeter of the circle whose diameter is 1; or by putting the sum of this series equal to s, it has the ratio sqrt(6) multiplied by s to 1 of the perimeter to the diameter. I will soon show that the sum of this series to be approximately 1.644934066842264364; and from multiplying this number by six, and then taking the square root, the number 3.141592653589793238 is indeed produced, which expresses the perimeter of a circle whose diameter is 1. Following again the same steps by which I had arrived at this sum, I have discovered that the sum of the series 1 + 1/16 + 1/81 + 1/256 + 1/625 + etc. also depends on the quadrature of the circle. Namely, the sum of this multiplied by 90 gives the biquadrate (fourth power) of the circumference of the perimeter of a circle whose diameter is 1. And by similar reasoning I have likewise been able to determine the sums of the subsequent series in which the exponents are even numbers.}

\section{Prime pair sets}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 26033. \textit{Solved: Mon, 10 Aug 2015, 12:37}.

\textbf{Math knowledge used}: Erathostenes sieve and Miller-Rabin primality test.

\textbf{Programming techniques used}: dynamic programming/memoization (sort of).

I find that $20\%$ quite reasonable. It's not like this is a super difficult method, but it's tricky to get it right, there is no obvious solution (no, the solution is not the one for $4$ primes plus an additional one) and getting it efficiently can be a challenge. I used a complicated structure with trees where for each prime I stored possible combinations of less than $5$ primes verifying the conditions. For each prime, and for $n\in\llave{0,3}$, I have a tree storing the combinations including the prime and $n$ additional numbers. So, each time I add a prime, I need to traverse the structure for each prime less than the one given, and if I can traverse successfully a tree of level $3$, then I can add the three associated numbers, plus the prime ``owner'' of the tree, plus the prime we're currently iterating. It's a bit weird but it's efficient and the code is not that complicated.

This is also the first problem where my algorithm took more than $1$ second. A bit more than $5$ seconds, in fact. The final solution is composed of these primes: $\llave{13,5197,5701,6733,8389}$.

\section{Cyclical figurate numbers}
\textbf{Difficulty rating}: 20\%.

\textbf{Solution}: 28684. \textit{Solved: Mon, 10 Aug 2015, 13:34}.

\textbf{Math knowledge used}: polygonal numbers.

\textbf{Programming techniques used}: none.

This is very fast because the obvious way is to start the iterations from the octogonal numbers, since there are fewer of them, and it happens that the octogonal number is the smallest of them all. Although it's not like it would be horribly slow otherwise.

The method is: generate all the triangular, square, pentagonal, hexagonal and heptagonal numbers. You can use a map for each type, or a single map with all the data with a tag indicating the kind of polygonal type. Index the map by the first two digits of the polygonal number. Then, iterate over all the octogonal numbers, and follow a recursive search where at each step you look for the first two digits in the map, which come from the last two digits of the previous number. The search succeeds when all the polygons have been fulfilled and the end digits of the last number are the first ones of the first octogonal number.

This is the chain:
\begin{equation*}
\hspace{-1.5cm}
P_{8,21}=1281\Rightarrow P_{6,64}=8128\Rightarrow P_{5,44}=2882\Rightarrow P_{3,128}=8256\Rightarrow P_{4,75}=5625\Rightarrow P_{7,32}=2512.
\end{equation*}

\section{Cyclical figurate numbers}
\textbf{Difficulty rating}: 15\%.

\textbf{Solution}: 127035954683. \textit{Solved: Mon, 10 Aug 2015, 13:57}.

\textbf{Math knowledge used}: none.

\textbf{Programming techniques used}: none.

Very simple, just use a Multimap-like cache with the digit representation of all the cubes (the key should be a summary of the digits that doesn't take the order into account; an IntIntMap of digit to count of digits is good enough), update it with all the cubes, and stop as soon as the current digit representation has $5$ different values.

The cubes that share the same digits are: $5027^3=127035954683$; $7061^3=352045367981$; $7202^3=373559126408$; $8288^3=569310543872$; and $8384^3=589323567104$.

Updating the code so that we can find the solution for values of $N$ greater than $5$ shows that the solution grows relatively slowly, and the execution time is not preposterous. For example for $N=15$ the cubes are between $47456^3=106874325794816$ and $95636^3=874710238619456$, and the solution is found in less than $15$ seconds (the one for $N=5$ takes a bit more than $0.2$ seconds).











\end{document}
